Title: Excel VBA Advanced Tutorial
Channel: Learn Skills Daily
Video ID: MeKL_n6SiYY
URL: https://www.youtube.com/watch?v=MeKL_n6SiYY
Duration: 1:56:51
Level: ADVANCED
======================================================================

Table of Contents:
- 0:00 Start / Variables
- 7:59 Variable Rules
- 11:18 For Next Loop Basics
- 15:44 For Next Loop Doubled
- 19:47 For Next Loop Triple
- 22:11 For Each Loop
- 23:50 Exit For Statement
- 27:07 Do While Loop
- 30:32 Do While Not Empty Loop
- 32:53 Do Until Loop
- 35:11 Do Loop UNTIL
- 36:49 Count and Offset
- 48:23 End, Address, Call Statement
- 55:35 Practice
- 1:03:47 Using the FIND Tool in a Macro
- 1:14:50 Message Boxes
- 1:22:58 Input Boxes
- 1:27:16 Code Continuation Character and vbCrLf Constant
- 1:33:44 If Then, ElseIF, and Else
- 1:40:13 Select Case
- 1:42:58 Multiple Variables
- 1:46:09 Practice

Key Topics Covered:

1. VARIABLES IN VBA
- Declaring variables with Dim
- Variable data types (String, Integer, Long, Double, Boolean, Date, Variant)
- Variable naming rules and conventions
- Scope of variables (procedure-level, module-level)

2. FOR NEXT LOOPS
- Basic For Next loop structure
- Step values (increment/decrement)
- Nested For loops (doubled, tripled)
- For Each loop for collections
- Exit For statement

3. DO LOOPS
- Do While loop
- Do While Not Empty
- Do Until loop
- Do Loop Until (post-test)
- Loop control and exit conditions

4. WORKING WITH RANGES
- Count property
- Offset method
- End property for finding last row/column
- Address property
- Range references in code

5. THE FIND METHOD
- Using Find in VBA
- Find parameters (What, LookIn, LookAt, SearchOrder)
- FindNext for multiple matches
- Error handling with Find

6. USER INTERACTION
- Message boxes (MsgBox function)
- MsgBox buttons and icons
- Capturing user responses
- Input boxes (InputBox function)
- Validating user input

7. CONDITIONAL STATEMENTS
- If Then statement
- ElseIf for multiple conditions
- Else clause
- Nested If statements
- Select Case for multiple values

8. CODE ORGANIZATION
- Call statement for running other macros
- Code continuation character (_)
- vbCrLf for line breaks in strings
- Multiple variables on one line

======================================================================
FULL TRANSCRIPT:

### Result
"Chelsea Dohemann: Welcome back as\nwe move further into VBA, we'll need VBA to be able to remember things. So we're going to be starting to use. What's called variables. Variables are small pockets\nof computer memory used to store and retrieve information. We can use them to store numbers or text\nor ranges of cells, charts, or pretty much anything you're going to want to\nopen up the file called simple variables. And once you open that up, make sure to\nalso get open the visual basic window, and you'll see that there are a number\nof macros already created in here. Now, if I wanted to be able to retrieve\ncertain information from another location or retrieve certain information\nthat I've stored in VBA and be able to use it here in my interface, I'm\ngoing to need to use a variable to do. And here's how they work. First of all, we need to list exactly\nwhat kind of a variable this is. Notice the beginning of this statement\nstarts with the letters D I M that stands for declared in memory. And this is how we tell VBA\nthat we're going to be using the next word as a variable. This is essentially a pocket or a bowl\nor a backpack or something like that. Something that's going to be able to\ntemporarily store a bit of information. And then we need to explain for VBA,\nwhat kind of content is going to go in there in this case, I'm saying\nintegers are going to go in there. That's all that's going to go in there. And that's going to make it\neasy for VBA to keep that data size and appropriate size. In this case, the integer\nsize is rather small. And so I like to specify for\nVBA that it's going to be small. In this case, I actually\nassigned a number of. So I've already told VBA that\nI'm going to create this pocket. It's called a number, and now\nI'm going to give it a value. So I'm saying this thing that\nI made called a number of this little pocket, that's going to\nhold the value of two for now. And then in this third, little bit here,\nI've actually assigned a task for this I've said, okay, I have a cell range,\na five, and the value of that range. I want to be specific, stored value. And if I run this macro here,\nyou'll see that over here, the value of that cell has now changed. Now, of course, the formatting here\nneeds to be changed back to something like general for me to actually see the\nnumber two, or if I change that to a date format, of course it looks a little silly,\nbut if I wanted it to be January 2nd, 1900, I would have exactly what I wanted. All right, we're going to keep going. The next few examples are\nmostly for practice for you. In the next example, we're\nactually storing date values. This is an example of a date variable. So we're saying this is going\nto be a variable called a date. And the data type is going\nto be a date data type. Then we actually assign a value. We say, okay, this thing that we\nmade called a date, we're going to grab the content from . Now\nIwan is located right up here, and that happens to have a date in it. And so this is appropriate. I've stored this as a date data type,\nand now it's going to store dates. What you don't want to do is store\nvariables as the wrong data type. Now, there are lots of different\ndata types for variables. You want to make sure to use\nthe right kind of data type when you are creating a variable. If you're going to be\nusing texts, use text. If you're going to be using numbers,\nuse numbers, and if you're going to be using true or false, make\nsure to use the Boolean data. This is a list of common data types\nthat you'll want to be aware of. Numerical data types include the decimal\ndata type, which is not the smallest data type you can have, but it does\nallow you to have decimal placeholders, which is nice for you're going to be\ndoing calculations with many decimals. The double data type is for relatively\nsimple numbers, something with not too many decimal placeholders. And then you have the intruder\ndata type, which doesn't allow any decimal placeholders whatsoever. You'll see, as they're allowed\nto be more and more simple, they take up less and less space into\nyou're only taking up two bytes. There are many different\nkinds of text data types. The first one I've listed\nhere is called variant. Now variant doesn't actually need to\nbe text variant can hold anything, which is why it's called variant. That's also why it's so big. So you'll want to make sure not to\nuse variant unless you really truly don't know what kind of data is going\nto need to be housed in their event. The most common text data\ntype is the string data type. The size of that variable does\ndepend on the amount of content that you're storing there. So keep that in mind. It can hold quite a bit of content, but\nit can also take up a bit of space if it holds a lot of content and then you have\nthe char or care data type that handles mostly smaller sets of information. We also have the bullying and bite\ndatatypes bullying only handles true or false, which makes it\nrelatively small, only two bites. And then we have the smallest of\nthem, all the byte data type, which only takes up one bite and can\nonly hold values from zero to 255. And then we have a group of\nmiscellaneous data types here. We have the date data type that\nwe just saw an example, a moment ago, we have object data types\nthat can hold things like charts. And then we have the range data\ntype, which you may have seen in an example earlier, which actually\nremembers ranges of cells in your work. Coming back in our document here. You'll see that if you scroll\ndown a little bit, there is a macro called string variable. This is an example where you can\npractice creating a string variable. I'm going to do it really quick,\nand then you can do it on your own. I'm going to start by declaring my\nvariable with the dim as statement what's referred to as the dim, as course,\nD I M stands for declared in memory. So I'm going to name this a product as\nstring, and that's going to let VBA know that the only kind of content that's\ngoing to be stored here is string content. Now I'm actually going to place\nsome data inside of my variable by saying my variable that have named\na product that should hold the information that's in cell G three. So I'm going to say range T3 value\nthat's in that range should be stored in my variable called a. And now I'm going to\nactually use that content. Now that it's remembered that content\nI'm later going to be able to use it. And let's say later on in cell\nB five, I'm going to go on to be using that content a product. And if I run this macro here that I've\ncreated, you'll see that it puts in the name of that particular product there. It just so happens that I need to\nmake this column a little bit bigger. There we go. And now I can see the entire name. All right. So the rest of the variables that\nare in this worksheet are for you to practice on here's a number variable. If you scroll down, you'll see an\nexample where you can get to your variable to increase in value. And then at the bottom, there\nis a macro that is designed to run all of the above variables. There is a little bit of lingo\nin here called a call station. We are going to be talking\nabout that later on. So if you don't feel\ncompletely comfortable with it yet, don't worry about it. We're going to cover it. Go ahead and pause the video. Come on. Back when you're done, there are a\ncouple of other things that we want to know about variables before we go and\nstart using them in our VBA language. And here's what they are. There is a naming convention\nfor variables, and there's certain ways to treat them. First of all, this dim as statement\nis not actually necessary. However, if you don't include the dim\nas statement, then the data type that gets assigned to that variable is the\nvariant data type, which as we learned earlier is pretty byte expensive. So we want to avoid that. And so that's why we tend to put the\ndim as statement at the beginning of all of our variable names. Now you can force people to put in the\nDMS statement at the beginning of all of their variables in the way that we do\nthat is with an option explicit statement at the very top of our macro code. So you can go all the way to the top\nof your macro code, above your sub statement and type in option explicit. And that's going to make sure that\npeople have to declare their variables. They can't just go making any\nvariable that they want whenever they want by saying like, this\nis a variable and just using it. Okay. So we want to make sure that we do have\ndim as statements, and we're going to use the option explicit at the top of our\ncode in order to make sure people do that. The other thing that we want to be\naware of is that there is a naming convention for our variables. They have to start with a letter. They can't have any spaces and they\nneed to have 255 characters or fewer. I'll give us an example. So here's an example of an\ninappropriately named variable. I have a space and the moment I\ntry and execute that variable, it says you can't do that. Okay. So no spaces inside of our variable names. Also it needs to start with a letter. If I accidentally put a number as\nthe beginning, watch what happens. So it doesn't accept that either. And the third thing we want to be mindful\nof when we're naming our variables is not to name them after a existing\nproperty method, active sheet here. Now watch what happens when I hit enter\nit actually lets me name it that, and then I can store information inside\nof this variable type, for instance. And then I can use that later on. I'll say, I want to assign,\nsell a one as the value of what I've put inside that variable. And if I run this right now, It actually\ninserts that numerical value there. So it worked as a storage space. However, later on, if I decide to\nuse this particular variable and I actually want to use the object\nthat it's named after, maybe I want to rename my sheet here at the end. I want to rename my sheet, this\nwork, and now I want to run my code. It says, oh, I can't do that. So we also don't want to name\nour variables after any existing objects, properties, or methods. And if we stick to those guidelines,\nwe're going to be safe with our variables. And this last example, we were able\nto get VBA to fetch information about a particular product and populate it\non our list on the left-hand side. However, if we wanted to do that for\nmany different products, it would start to become rather time consuming\nto do that within VBA and less, we started to incorporate what's called. And that would be able to populate\ninformation for multiple different products in order to do that, you're going\nto want to open up a file called for next. The for next loop is going to be\nthe file that we're working on next. There are a few different kinds of\nloops within VBA, but we're going to be focusing on two different kinds\nof the for-next loop and the do loop. We're starting with the, for next loop. Go ahead and open up this file called\nfor next loop on the left-hand side, and then the VBA window associated\nwith it on the right hand side. You'll see that there's already some\ncode in here that's populated for you and you can use it to follow along with me. I'm going to create mine from scratch. Now loops do require us\nto create a variable. For an X loops are the first kind of loop\nthat we're going to be talking about. And what they do is they loop through\na certain process of specific number of times, meaning you tell it how many times\nto go through this particular process. If I wanted to, I could say I want\nit to happen 10 times or happen a hundred times or something like that. I'm going to need to declare a variable\nhere because eventually I'm going to want my loop to happen across all of\nthese different rows in this green area, on the left-hand side of our document. So I'm going to create a variable\ncalled X and I'm going to make it a integer variable because eventually it's\ngoing to be representing row numbers. And my row numbers are only ever integers. It basic for next loop starts\nwith the force statement. And then you declare exactly what\nthe value of your variable should be. So. For X equaling one to 10, that means\nthat this loop is going to happen when X is equal to one it'll happen when X\nis equal to two, it'll happen when X is equal to three to four, to five, to six,\nand every single possibility in between. Now I've already declared that X\nis an integer, which means that it can only happen when it's\nequal to one or two or three. It cannot do 1.2, 1.3,\n1.4 or anything like that. So in this case, X is only going\nto equal 1, 2, 3, 4, 5, 6, 7, 8, or nine or 10, meaning this loop is\ngoing to happen 10 times altogether. Now, what I want to eventually loop is the\nprocess by which I'm going to insert the value of 100 into each one of these cells. And so I'm going to use\nthe code that says cell. And I'm going to start with\ncell one, comma one, that's sell a one as we know it. And then I'm going to say, I\nwant that to have a value of 100. Now, if I executed this right now, well,\nit would have a problem because I've started a for-loop without the end of it. But if I were just to execute this\none little statement that says this sells line right here, the value of\n100, all I would do is input that value into cell a one, but I want\nthis to repeat every single time. So when X equals one, I\nwant it to be in row one. When X equals two, I want it to\nbe in row two when X equals three, I want it to be in row three. And so instead of actually putting the\nnumber of the rows here, what I can do is simply say X, because then when X\nequals one, the row will be one as well. When X equals two, the\nrole will be two as well. And I have to end my four next\nloop with the next statement. This is my ending bookend that basically\nsays to go back to the beginning and start the next loop for the next value of X. And if I execute this, it happens too fast\nfor me to watch, but the value of 100 got inserted into each one of these cells. Go ahead and give that a try\non your own and come on back. And the last example, I was very\neasily able to populate this entire column of information and exact\nnumber of times exactly as I wanted. However, if I wanted to populate the\nnext column over, I'm going to have a little bit of difficulty because\nthe way that my macro code is set up is to automatically presume that I'm\nonly going to operate in column one here, where it says column one, watch\nwhat happens if I change this to add. If I think maybe I can get the next\ncolumn over to happen and the next column after that and the next column after that\nand all the way through the 10 columns. After that, when I hit play, watch, when\nX is equal to one, it populates a one. When X is equal to two, it only\npopulates B2 when X is equal to three only see three, et cetera. So that's not exactly what I\nwant to be able to do here. I want to be able to populate more\ncolumns of information right here. I don't want to have that value that I'm\nlooking for populated across those rows. If you want to be able to populate\nmultiple columns or multiple rows with the same for next loop, you're\ngoing to need to create what's called a double for next loop, which is\nbasically nesting one inside the other. It's not as complicated as it sounds. We're going to start by declaring\ntwo variables this time one for each of the four next loops\nthat we're going to be CRE. I'm going to start creating my variables\nwith a very specific name, like I N T C O L I N T for integer and C O L as the\nname of what it's eventually going to fill, which is the column in this case. And I'm going to say, this\nis an integer variable, and I'll create one more for rose. Now that I've declared my variables, I can\ngo ahead and make my four next statement. So I'll start with my four. And I'll say when int call is\nequal to one through three. Okay. So I want three columns of\ninformation populated here. Okay. When, when it's equal to one through\nthree, well then my cells, I'll just start with the basics here. I want the value to say\nsomething like, wow, this word. And then of course, I'll have to end this\nnext statement by saying next into call. However, if I were to try and add\nthat second access onto my for-next loop, I'm going to need to add\na secondary for next loop inside of the one that I already have. So I'm going to start by placing my\ncursor at the end of the previous four. And I'm going to make\nanother one for int RO. And I'll say, I want this to\nhappen for 10 rows altogether. So one to 10. Now the trick with nesting one for\nnext loop inside of another is that whichever one is on the inside has to be\non the inside in both cases during the for statement and the next statement. So I'm going to make sure\nthat my next statement for my row is on the inside as well. And I'll say next int. Now, of course, this is only going to\nwork for cell a one at this point, unless I specify for my cells object that when\nintro equals one or two or three or four or five or six or seven, et cetera,\nthat I want that to get populated. And when the column equals one or two\nor three, that that gets populated and here we go, let's test it out. That's pretty cool. Give it a shot yourself and come on. And now we're going to take the\nidea of a double for-next loop and turn it into a triple for next loop. So the double was able to populate\ninformation down a column and across a row and create a, basically\na table of information for us. But what if we wanted to do this over\nmultiple different sheets, you could basically add a third dimension to your,\nfor next loop and be able to do that. It's going to require the exact\nsame principles that we learned in the double for next loop. So I'm going to declare three different\nvariables this time, one for columns, one for rose, and one for sheets. Then I'm going to put in the\nbeginning of my four statements. So I'm going to start with my\nfour statement for the sheet. And I want this to happen on this\nsheet and the following two sheets. This one happens to be number three in the\norder of all the sheets in the workbook. So I'm going to say three to five,\nand then I'm going to start my for next loop for the columns. And I want that to happen over\nthree columns and then my rose, and then the actual code\nthat I want to execute. I am going to need to be specific\nenough to say exactly which worksheet I want this to execute\non, but lucky for me, my variable is going to determine that for me. And then I'll do the same code\nthat we had last time, which is the cells using the variables. And then I'll input a value there. Uh, And I'm going to have to\nfinish out my next statements. They are going to have to be in\nreverse order of the four statements, just like we saw last time. And assuming I've spelled all my variables\ncorrectly, I should be able to press play. And then of course it happens\non this sheet on the next sheet and on the sheet after that a for each loop is a for next loop,\nbut it operates on entire collections. So in this case, we have a collection of\nworksheets in this workbook altogether. They make up the collection\ncalled worksheet. And so if I have something that's\na collection like worksheets, then I can say, I want to do this\nparticular thing to every single thing in that particular collection,\nI'm going to go ahead and establish a variable justice we have before. Except I'm going to say that this\nis actually a worksheet here, and we will be talking about the\nworksheet object and the worksheet collection later on in this course. But if I wanted to use the, for\neach loop to do this, it would look like this for each X in the\ncollection called worksheets. And maybe in this case, I just want to\nget a nice little message box to pop up. And we're going to be covering message\nboxes later on in this course as well. But maybe I want it to tell\nme exactly what the name of that particular worksheet is. And I'll concatenate this with\nX, which is my variable and the name of that particular worksheet. And then I'll finish out\nthis with my next statement. So it's finding each one of\nthese worksheets and telling me exactly what the name is, because\nthat's what I've asked it to do. So it's going to operate this particular\nfor next statement for every single one of the items, every single one\nof the worksheets in this case, in the collection called worksheets. Go ahead and give that\na shot and come on back. And finally, the last of the four\nnext statements we're going to cover is the one that actually\nrequires an exit for statement. The exit four statement is used\nto exit the, for next loop prior to the actual ending statement. Okay. So if you have a clause in here that would\nrequire you to exit the loop early, that's what the exit four statement is used for. Now, in this example, we're actually\ngoing to be utilizing an if then statement, which is something we're going\nto be covering later on in the course. So just go ahead and bear with. While we check out the\nexample of this, I'm going to declare my variable as normal. Then you use X and that's going\nto be an integer of course. And I'll say for X equals one\nto 50 for gemein equal sign. There we go. All right. And I'm going to say that I want\nto select range, be something and the road that's going to be\ndetermined here is going to be based on whatever my variable is at the moment. So when it goes through this the first\ntime I want to be on V1 when it goes through it, the second time I want\nto be on B2, when it goes through a third time, I want to be on B3. So I am going to use my\nvariable to determine that. And then I'm going to select that cell\nand I'm going to input a particular value. If the word doesn't stay, stop off. If the word stop is not\nalready populated in that cell. So I'm going to put a little test in here. It's basically going to say, do this,\nkeep doing this forever, unless you actually run into a value that's\nalready in that cell that says stop. And this is what that\nstatement would look like. Keep in mind, we haven't talked\nabout the, if then statement yet. So don't worry about completely\nfeeling comfortable with this, unless that cell says stop. In which case, exit my four statement. And that's what the exit four looks like\nnow in the case that it doesn't say stop. I do want it to continue going. So I'm going to use an LSF statement. And again, we are going to\ncover this later, so don't worry about it too much right now. And if it doesn't say the word stop,\nthen I want it to populate the word info over and over and over again. So we're going to be saying, if it says\nstop, then exit the forest statement. Otherwise if it's empty, then putting\nthe word info and we'll cover this later, but I do have to put in an end Def and\nthen of course, like we are used to, I do need to put in my next statement\nto finish out my for-next next loop. And then when I go ahead and play this,\nthe word info gets populated over and over and over again, until it runs into a\ncell that already has the value of stop. Go ahead and give this a shot for\nyourself and come on back and then we'll move on to other kinds of. In the last video, we saw an example of a\nloop that was going to perform its action over and over and over again and less,\nsome kind of a logical test was performed. And if that test equivocated to true, then\nthe loop would stop itself prematurely. That was the exit four statement\nthat allowed us to do that. But let's say we wanted to be able to\ncreate a loop whose sole job wasn't to do that loop a certain number of\ntimes like the four loop, but maybe what it was supposed to do is simply\nperform its task ad infinitum until some particular criteria was met. That's what we call a dual loop. Now there are a few different kinds of do\nloops that we're going to be exploring. We're going to start with the do wild. This loop performs its action\nover and over and over again. While a particular criteria is met. Another way of phrasing. This is to say that it performs\nits loop over and over again, while a certain test equals true. The moment that test equals false is\nwhen the loop actually stops itself. So if you open the file called dual\nloop on the very first sheet there, which is called the do while loop open\nup your visual basic for applications interface, and you'll see on the\nright-hand side, that there are already some macros in here that are designed\nfor you to be able to follow along. I'm going to remove the code\nwithin my macro so that we can go ahead and do it together. In this first example, what we're\ngoing to be doing is asking visual basic to perform a particular\ntask, a certain number of times. We're going to be asking it\nto perform this particular task while X is less than 10. In this case, we're going to be\nestablishing a variable, just like we did with the, for next loop. So I'm going to say dim X as\ninteger, and this is a do while loop. So I'm going to say do while\nX is less than a value of 10. Now I'm going to be using cells again\nto refer to each cell reference. And I'm going to be saying while the row\nis a numerical value of one or two or three or anything less than 10, I want\nit to select that particular row and stay in column one and put a value in there. Uh, let's say, cool. Here's the neat thing about the do loop. Now what I'm going to say is the new X. Equals X plus one. And with that, the value of\nax is actually increasing. Now I do need to put a\nbeginning value of X. So I'm going to go ahead and\ndo that here at the beginning. I'm going to say X starts as a value of\none, and then it goes through this loop. The last thing that it does in the\nmiddle of this loop is to add one to its own value, thereby increasing\nits value by one each time. And now I'm going to close out\nthe loop by putting the word loop at the end and let's run it. And there we go, go ahead and do that\nfor yourself and come on back and we'll look at the Duwell not empty. And this next example, we're going to be\nmanufacturing our own Dyl, not empty loop. So I'm going to start just as I\ndid before by declaring a variable. And I'm going to start with the\nvalue of five, because I want my loop to actually start on row five. I'm going to start by\nusing the do while loop. And I'm going to say, do while\nthe cell, the value of that cell is not, that's what those two\noperators next to each other mean. There is not empty. And by putting those two quotation next to\neach other, we are basically saying empty. All right. And then on the next line, I'm\nactually going to say what I want to happen in the loop. So while there's stuff in here, I want\nto perform the loop until it's empty. This is a process by which\nyou can basically have the auto-fill handle operate. Like you can imagine an\nautofill handle operating. If you were to do this in Excel\nand you were to double click on the auto fill handle and it populates\nto the bottom of a dataset. Well, that's basically what we're\ngoing to be manufacturing here. So we're going to be watching the\ncolumn to the left and we're going to be performing the following bit\nof code while the columns adjacent to it are filled with contents. So I'll say cells X three, that\nmeans whatever iteration of the loop we're on and in column three. And the value of that should be whatever comes from the\ncolumn to the left of it. I'm going to say plus 30 days, and that\nway I'm going to be using the dates on the left-hand side and adding 30 days to\npopulate a column of information about the due dates for these particular items. And then of course, I'm going to\nend my dilute by saying, okay, the next X equals X plus one. I'm going to finish that\nout with the loop bookend. Now I have all my due dates, give\nit a shot yourself and come on back. And now it would be helpful for us to be\nable to learn how to do a dual loop that instead of performing the loop wireless\ncertain criteria equivocates to true. Maybe we want to have a do loop\nthat performs its action until a criteria equivocates itself to true. That's what a do until\nloop is going to do. So I'm going to start off by\ndetermining my variable again. So I'm going to call this one intro. This is going to be my integer, and I'll\nstart off with a value of one for that. And then here's how the do until\nworks do until, and then you put whatever criteria needs to equivocate\nto true for this loop to stop it. Now, there's this really neat\nlittle clause that you can put in here, which is called is empty. And basically what it does is it,\nit performs a logical test to see if a particular cell is empty. All you have to do is specify which\ncell and I'll just say, cells intro. Okay. So what I'm doing right now is\nI'm performing a logical test to see is this cell empty? If this cell is not empty, it's\ngoing to continue the loop. If that criteria does equivocate to\ntrue in this case, this cell is empty, then it will actually stop looping. So here we go. Let's finish this out. I'll say in the case that it is not empty. I want you to change\nthe value of this cell to info. And then I do need to. Like normal with a Deloupes loops. I do need to increase the\nvalue of the next loop around. So there I go, applying my\nstep value, then I'm going to finish this out with the loop. And here we go. That is the do until loop, which\nperforms its action until a particular test equivocates to true\nin this case until a cell is empty. And there's one more iteration\nof the du antilope, which we call the do loop until this sort of\ndepends on your personal preference. Whichever one makes more sense to you\nis the one that you should utilize. There's not a whole lot of\nsituations in which you would need to use one rather than the other. However, it is pretty cool to go over. So let's talk about it instead of saying do,\nuntil we're going to say. And then way down farther, we're\ngoing to say loop until, okay. So here's how it's going to look. I do need to declare my variable. Of course, then I need to determine\nexactly which value that should start on. And then I'm going to say what I\nwant it to do over and over again. I'll choose the same word for this\nexample, and then I'll have it step up its value from the next time around. And then here's my loop until, and now\nI put my logical test here at the end. So this is just another option for you. Give that one up. And the real test is to see\nwhich one you like better. Some people like this, one, some people\nlike the one that we did before you decide on whichever one you like better is the\none that you should carry along with you. Now that we know how to create loops,\nwe're probably going to want to start to be able to generate reports\nbased on content that's already in our workbook in order to do so. We're going to need to know a few\nbasic vocab terms in VBA, and then we'll be able to really easily\nbegin to code report generators. A few bits of vocab that we're\ngoing to need to cover in this section is worksheets, including\nthe following worksheet stock count. That might count the number of\nworksheets that's in my workbook. And I could ask the question of\nthe immediate window, how many worksheets are in my workbook. It turns out that there are five. So I just used the worksheets\nobject and the count method in order to be able to determine. I can also use the offset method,\nwhich allows me to navigate from a given cell into other cells. For instance, if I take the cell that\nI've already selected, and then I put in an offset method, I can then specify\nwhere I want to move from the given cell. You can see that I've started by\nentering in the word selection. That's going to take into account the\ncell that already selected an offset from there, which means that I'm going\nto travel in a certain direction. Now, the offset allows me to determine,\nfirst of all, how many rows I want to travel downward or upward. If I use a negative number and then\nsecondarily allows me to determine how many columns I'm going to\nmove over to the right or left. If I use a negative number there in\nthis case, if I use a one comma zero that is indicating that I want to move\none row down and zero columns left. And then I will select that. And if I execute that in the immediate\nwindow, see my cell moves down one. I had some content in that particular\ncell that I wanted to be able to copy and paste in another location. I could simply say selection dot copy. And then I could say selection dot offset. I'm going to move down. And then I can say active sheet dot paste. Now the copy and paste\nis a little bit tricky. The copy is easy, but the piece\nis a little bit difficult when it comes to pasting you can't\nactually paste in a range. If you wanted to paste in a range, you\nneed to use the paste special option. The paste method is only a method\nof the active sheet object. And so keep that in mind, you are going\nto want to mention active sheet dot paste. If you want to use paste, or if you\nwant to use range or something else of the sort you want to use paste special. Like, so that's what\npay special looks like. Of course it doesn't apply to\nactive sheet, but nonetheless, that's what it looks like. All right. Keeping into account. All of these terms, we can very easily\ncreate a report generator in this document here, this document called\nworksheets count, offset, and copy. We're going to be able to\nexemplify all of the above also, including a simple for next loop. This is going to be a precursor to the\nfollowing exercise, which is going to be a little bit more challenging and\ntake into account everything that we've learned so far in this particular class. All right. So in this particular doctor, The\nlast sheet is called P and L, which of course stands for profit and loss. And let's say for instance, I want\nto be able to copy the information from all my other sheets. I have sources of revenue, other\nincome expenses, and taxes, and I want to be able to place them all on\nmy profit and loss sheet at the very end, in order to do that, I'm going to\nneed to create a loop that determines exactly how many sheets I have in my\nworkbook, and then is able to iterate that loop to copy and paste content\nfrom each given sheet, the appropriate number of times, depending on how many\nsheets actually have in that workbook. So I'm going to start by\ndeclaring a couple of variables. So I'm going to use X. This is going to be used\nfor my, for next loop. I'm going to say dim X, as\ninteger as we were doing with our four next loops previous. I'm also eventually going to want\nto save these sheet names from each of these sheets so that I can put\na little, a nice little label on my profit and loss statement, right\nabove where I'm going to paste the content from that particular sheet. So I'm going to go ahead and\ncreate a variable whose sole job is to remember the sheet titles. And though she titles are\ngoing to be stored as text. So I'm calling that a string\nvariable, and I'm going to start my for next loop for X equals one two. Now I could say five or four, rather\nbecause I want this to iterate four times. I have five sheets in total, but\nI don't want this to iterate for my profit and loss statement. So I'm going to say for X equals one to\nfour, but let's say for instance, in the future, I might add other expenses or I\nmight add other sheets into this workbook. I want it to be able to be\nrather flexible in that case. And so I'm going to have VB figure out\nwhat the count is of my worksheets. And then, because I don't want this\nto happen on the very last sheet. I only want this to iterate\nthe total number of sheets, except for this last one. I'm going to say worksheets dot count\nminus one to account for this last one. I don't want it to happen\nfor the fifth sheet. This is my final sheet here. All right. And then each time it goes through\nthis loop, I want it to grab the given worksheet for X this time. It will grab sheet one and it will select. And then I want it to immediately\nstore the sheet title. That's that variable that I had created\njust to remember the sheet title of the active sheet and the way that I do\nthat is by saying active sheet.name. And that's going to store the name\nof that particular active sheet. We learned how to use\nthe name method earlier. And then finally, I'm going to\ngo to the last sheet in here, which is called worksheet. It's called P and L. And I'm going to select it once there. I'm going to start with range a one. That's going to be a safe place\nto start, but from there, I'm going to need to offset or remove\ndown a certain number of roads. And I know that the amount of content that\nI generally tend to keep on these sheets is about four rows or so of information. So I'm just going to say selection\ndot offset, to move down to account for the content that maybe\nI've already placed in there. So we'll say offset a\ncertain number of times. Now, if I just said offset five\nrows or something like that, went to go paste the content from the\nsecond sheet, it would paste it over the content from the first sheet. So I'm going to say, instead of\njust counting five rows, I want you to multiply X times five. So the first time this goes\nthrough, it will offset by five. And the second time it goes\nthrough, it will offset by 10 rows. And the third time it goes\nthrough, it will offset by 15 rows. Now it's not actually going\nto offset by the full five rows as I'm thinking of them. It's gonna essentially\noffset is I four roses. We see them and that'll make a little\nbit more sense once we actually look at it, I'm going to put a plus two in here. That's going to give me a little bit of\nextra space in order to put my next title in there and then be able to go after\nthat and paste the content after that. So I'm going to put a plus two in here,\nand this is simply a trial by error thing. You would notice this, if you were\nmaking this macro on your own, you would be testing it out and\nyou would see that you need to put another couple of rows in here. And that's how this kind\nof things comes about. Then I'll select that cell. And I'm going to put in the title\nof this particular group of values that I'm going to be placing in here. Okay. So the value I'm going to put\nin there is the sheet title. From that very first sheet in\nthis case, maybe for good measure, I'll make it bold, make it look nice. All right. So we've put the title in there. Now we're going to have to go back to\nworksheet one or X rather select it and actually copy the content that we need. So I'm going to start by\nselecting reign J one. It just so happens that I keep\nall my content starting in cell, a one on that particular worksheet. And I don't know how much content is going\nto be there, but I want to grab it all. So I'm going to say selection dot current\nregion, which we talked about earlier. Dot copy. And then finally, I'm going\nto go to the sheets call. P N L select it. So I've selected the sheet I\nwant to be on, but what I want to do is take the active cell. Now, remember the active cell is wherever. I just pasted the title there. Okay. And I want to offset one\nrow down, select that cell. And then I'm going to say\nactive sheet dot paste. I'm going to finish out my, for\nnext loop by putting next decks. And finally, it's going to look a\nlittle bit funky at the end because it's going to offset by a whole lot. The very first time, the very first time\nit's going to offset by five rows plus two, which is going to look like seven. It's going to look a little bit awkward. So I'm going to grab rows. I only know this because\nI've done this before. No, grab those rows right there. Just a few of them, and\nI'm going to delete them. That's going to look kind of. All right now, if I were building\nthis from scratch, I would probably be stepping into this as I'm building it. So I'm going to go to the\nstep into process so that we can watch all of this happen. So here we go, starting with the very\nfirst X, which goes to the first sheet, grabs the sheet, title, copies it\nessentially, or rather stores it in a variable, goes to our P and L sheet starts\nfrom cell, a one offsets by seven puts in my sheet title there makes it bold. Then goes back to sheet one, copies. All the content here, goes\nback to my profit and loss. Offsets goes down by one and then\npastes here and then goes to the next iteration of this particular process. And if I step into the rest of this\nand go straight through it, you'll see that at the very end, when\nI put my last category in there. Now I have that big chunk of\nextra space, those extra rows. I remember I was saying at the very end,\nI'm going to have that weird little space. And so I'm going to select rows three\nthrough six, and I'm going to delete them. And there we go. And they got deleted. Everything got moved up and there's\nmy profit and loss statement. Go ahead and give this a shot\non your own and come on back. And then we'll have a nice big\nexercise to get a chance to practice everything that we've learned so far. Not that I know how to\ncopy and paste data. I now run into the issue sometimes of\nhaving a situation in which my data dump puts data in unpredictable places. For instance, I have a problem here\nwhere my data dump deliver some of the contents starting in row five, some of\nthe contents starting in row two, and some of the contents starting in row three. Now, eventually I'm going to want to be\nable to consolidate this all on one last sheet, but I am going to need to learn a\nfew little bits of VBA vocab in order to create a macro, that's going to find the\ncontent wherever it is on a given day. I'm going to start with a sheet\ncalled conservative and I'm in the document called address call and end. I am working within the macro\nin the module called completed. I am working within the macro called\nall macros, but that's because I'm working on the instructor file. You have a file called you try and\nin the, you try module, there's an area for you to follow along. And there are little directions in\nthere in the form of comments as well. All right. So I'm going to create a macro\nwhose job it is to travel along any particular column a and start\nto find the content that's there. It's also going to remember exactly\nwhere it found that content, so that later on it can grab all that content\nand then be able to copy it and paste it or move it to another location. I'm going to start by creating a variable. That's going to be able to later on\ncontain the content that corresponds to wherever the data starts in my worksheet. So I'm going to call this data start and\nI'm going to make this a string variable. That's going to store that cell address. It's a string for now, which\nwill work for me for now. And I'm going to start\nby selecting sell a one, just so happens that conveniently\nenough, my data dump does always start in column a it's just the road\nthat I'm a little bit unsure on here. And what I'm going to do is I'm going\nto use, what's called the end product. The end property allows me to\ntravel in any particular direction. And it stops when it sees\na break in the pattern. So if there's nothing in a certain\nnumber of cells, it will travel all the way until it finds something. If it starts in a cell that actually has\nsomething and I use the end property, it will then travel in a particular\ndirection until it finds nothing. Okay. So it's following the\nparticular pattern here. And indeed, if I use the immediate\nwindow to say the given selection, I want to end or rather travel\nin a particular direction, that's what this little bit of vocab does. And I'm going to specify the direction. I'm going to say XL down the other\noptions that we have our XL up. And then we also have\ntwo right or two left. I'm going to use XL down here. And then I'm going to say select and\nwatch what happens when I execute that it travels down to the beginning of\nmy data and actually selects that. So that's what the end\nmethod allows me to do. And then I want to be able to actually\nrecord the address of the particular cell, where I ended up there. What's going to allow me to\ndo this is the address method. So I could say selection dot address. And let's say, I turn this into a\nquestion from my immediate window. Watch what happens. It actually tells me what address\nthe cell is that I'm in right now. It does return it as an\nabsolute cell address. That's sort of one of the\nproperties of the address. And once I've done that, now\nwe'll be able to actually store that address in the variable that\nI've created called data start. And then later on, I'll be able to copy\nand paste all the content that I want. There are a couple of macros\nalready in here that select all the content and the current region,\nwhich we've already gone over. And then it also puts in some nice\nlooking headers for me as well. So they're already a couple\nof macros that are in here. That I'm going to use later\non, but for now, I'm going to focus on, is creating the macro. That's going to find the\ncontent wherever it starts. So I'm going to start in\nrange a one and select it. And then I'm going to say, okay,\nfrom the given selection, I want to use the end method to travel\ndown and select whatever cell it finds, whatever cell it ends up on. I want to store this in my variable. So I'm going to say data start\nequals the active cell dot address. And then maybe later on, somewhere\ndown the line, I want to actually refer to that range and I'll call it data\nstart, and then maybe I'll select it. This doesn't need to happen right away. It could happen much\nfarther down the line. I have stored this in my\nvariable, so it'll hang on to that until I exit this matter. Now that I've actually found the\ncontent that I want, or I think I have let's test it out to make\nsure that it's going to work. I'm going to click play. And indeed, I end up on cell a five. I'm going to click over\nhere, see if it works again. And there, it goes ending up on a five. If I go to one of my other sheets, I\nshould be able to click on this same button and it should be able to start on\na, to, and this one starts on a three. So my macro is working correctly. Now, while I got to get it to do is now\nthat it's actually found the content. I want it to be able to run\nthese other macros here. So copy and paste in a four, and\nthen maybe insert the headers as well in order to be able to do that. I'm going to need to ask\nthe other macros to run. And what I've done is I've created\nthis parent macro up at the top, whose job it is to run all the\nother macros that I've designed. And the statement that I'm going to use\nto call to those macros is called the. So I'm going to say, I'm going to\ncall to the macro called find data. Your macro is called, find your data. Then I'm going to call to copy\npaste in a four years is called copy paste in your a for, and then the third macro I have here\nis insert headers or insert headers. And once again, yours is\ncalled in your headers. Now that I've created all of these\nmacros and referred to them in one parent macro, all I should have to do\nis run this parent macro and it should take care of the whole job for me. And there it goes. Now I've put this handy little\nbutton in here, so you should be able to click on the button and it\nshould be able to run those as well. This is what it should look like if\nit completely works appropriately. Go ahead and give that. And when you're done, come on back. This is a practice video to allow us to\nrehearse everything that we've learned over the last session, we're going to\nbe creating a report generator, which is going to allow us to basically take\nall of the macros that we've created already, including this cool sort macro. We saw an example at the very\nbeginning of class of a sort of macro. This is an excellent Stuart macro here,\nand we also have a macro that inserts, columns and rows we've recorded. One of those earlier. We also created a macro that\ninserted some text for us. There's a macro that does all that. And then we also have a macro\nthat's going to format text. We created a macro earlier\nthat did that as well. However, what we're going to be doing in\nthis last example in this macro called gen rep is creating a report generator,\nwhich is what Jen rep stands for. Now. We're going to need to create our for-next\nloop, to be able to find a bunch of content and then be able to organize it. We also want our macro to go through\neach one of the sheets that are in this document, find all the content,\nmove it down a little bit, put in some headers format, those headers nicely. Now I do have macros that already\nformat headers, and insert those headers and insert columns above. And it's going to be able to do that\non every single one of these sheets. So I am going to need to call to\nthese macros that have already placed in here, and then I'm going\nto need to loop those multiple times that happens on multiple sheets. And then ideally on the very last\nsheet, I would love to be able to print out the content from each of those\nindividual sheets and place it directly. Right. I'm going to start by declaring\na variable that I'm going to be using in my, for next statement. So I'm going to call\nit X stem X as integer. And I'm going to start my four next\nstatement by saying four X is going to equal one to the total number\nof worksheets worksheet, stock count, except for the last one. So I'm going to put my minus one there. All right. And each time it iterates, I\nwant it to select the given worksheet, starting with one. That's going to select that worksheet. And then on that worksheet, it's going to\nsort the content on there, which I have a macro for in school sort last call. I'm also going to have it insert columns\nand rows, which are having a macro call. And all row. I also wanted to insert my headers. I have a macro for that called\ninsert text or insert TXT. And I want to format the content. I have a macro called FMT\nTXC that will do that. What this is going to do is\npush all the content, all each one of those sheets downward. And so I'm going to have one last sell\nhere that says all portfolios up here. And then the rest of my content\nis going to start underneath it on each one of those other sheets. So in this case, what I'm going to\nwant it to do is actually copy all that content and place it over here. So I'm going to say on each one of\nthose other sheets, select range B six, and then use a current region and select. And then it's going to be copying that\nfor the purpose of coming all the way back to this worksheet and pasting it. So now I'm going to say, go to\nworksheets called all portfolios, select the sheet, called all portfolios,\nand then I'm going to use my end property to be able to figure out\nwhere the previous content is ending. Okay. So I'm going to pay some content\nonce and then I don't want the next pace to paste directly over it. So I'm going to use the end property,\nfigure out exactly where the content that I previously pasted, where\nthat ends, wherever that ends. So a lot of folks like to navigate\nreally far down on their worksheet, farther than they will ever go with\nany pasted content and then use X L. In their end property. And what that is going to do is find\nthe very bottom cell in your worksheet that actually has data populated\nin it, or rather the bottom cell in that particular column that you're\ntraveling up in that has content in it. And then maybe I'll use my\noffset to navigate just a couple cells down Mel paste there. And that way I'm not going to be pasting\nover any content that's already there. So I'm going to start by\nselecting something really far down, I'll say B 2000, and then I'm going to use my\nend method to travel up L up we'll select whatever cell that. Then maybe I'll offset. I'll just move down a couple of rows\nthat way I'm not pasting over anything. Just two rows down, just select that cell. And then I'm going to put\nin a little title there. Notice in this case, I'm not actually\nstoring that worksheet name in a variable like we did in the last example,\nin this case, I'm just saying, Hey, that worksheet called such and such. Yeah. Put its name right here. And we did this in an earlier\nexample, and then I want the word portfolio to follow that. All right. So now that I got the title in here,\nlet's offset a little bit more. So we can actually pay some\nstuff, offset a couple more rows, and then we'll paste. Now we are going to have\nto put our next X in here. This is going to iterate\nthis multiple times over. And then finally, the last thing\nI'm going to need to do is clean up my columns a little bit. Cause they're going to look a\nlittle bit squished together. You probably already know how to\nautomate your columns in regular Excel. Here's how to do it in VBA. You're going to just refer to the columns\nthat you want to choose in this case. All that content is going to be in B3, E and then it's as easy as saying\nselection, not columns, not auto. I love that method. It's super easy to use. And assuming I don't have any spelling,\nmistakes that I missed while we were going through this, I should be able\nto execute this and it should be able to run this for every single one\nof my sheets, and then populate the final result on this particular sheet. And when I press play and choose\nmy gen rep or report generator and run it, there it goes. So I have all of my portfolios\nlisted there and also on all the other sheets in my workbook. I also have my nice titles put in here\nand formatted looks so much better. And there we go. Go ahead and give that a shot\nyourself and come on back. I'll move on to even more interesting. Welcome back. So we've made this really nice\nlooking macro over here, and it's created a nice little report at the\nend of our document here, and it is pasted each one of our portfolios. Now, the only thing I would like\nto improve a little bit is that I have these headers that say\nconservative portfolios, balanced portfolios, aggressive portfolios. And I do want that to be a\nlittle bit more nicely formatted on this final document here. So the last little bit of macro\ncode that we're going to incorporate into this port generator that we've\nbeen working on is a little bit of code that is going to format these. Now, this is a good opportunity\nto play with a new kind of code, which is the find. So there is a scripting\nstatement that allows us to be able to find certain stuff. And then later on we can\ndo something to it, right? So you may have used the find\nand select or the find and replace tools within Excel. And that's exactly what\nwe're going to be using. We are going to use the macro recorder to\ndo this because like the sort and filter macros, it happens to record very well. So we're going to start off our little\nbit of script with some manual scripting, and then we're going to actually create\nsome find script with the macro recorder. And then we're going to finish\nit out with a little bit more scripting, and then we'll be done. We are done with the file\ncalled report generator. So you can go ahead and\nclose out of that file. And now what we need to open is the\nfile called find macros the file called fine macros contains all the exact same\ncode that we've already been working on. And we're just going to\nadd a little extra piece. That's going to allow us to\nfind anytime the word portfolio. Is populated and then\nformat it a particular way. Now I'm going to need to put a loop\nin here so that it can find that word portfolio for every single sheet\nwhere it happens or rather for every single portfolio that we actually\nend up pasting here at the end. So I'm going to need to loop it for\nas many times as that particular word shows up in my spreadsheet. So I am going to need to put a loop in\nhere and I'm going to need to eventually put in a logical test that is able to end\nmy loop when a particular criteria is met. So the criteria that we're\ngoing to incorporate here, we're going to make a do loop. And the criteria that we're going to\nput in here is we're going to say, do loop while the cell that I started on\nis not the cell that I have ended up. So, as you may know, if you've used\nthe find and select tool or the find and replace tool, what it does\nis it finds, it goes looking for something, and then it goes looking\nfor the next thing after that. And so what you can do is you can\nhave it look for every incarnation of a particular word and then get\nit to format a particular way. And that's what we're going\nto be doing, but we do want it to eventually end that loop. And so what we're going to\nsay is, okay, I'm going to start on this particular cell. I'm going to find this particular word. And once I actually get back to that\nfirst cell, again, go through the whole document cycle, back around, come back\nto the beginning and land on that cell. That's when the loop should stop. So what I'm going to do\nis create a variable. That's eventually going to\nbe able to house the cell address of my original find. So I'm going to say found cell address,\nand this is going to be a string so that it can house the cell addresses. And we'll say that we'll\nalways start and sell before. Maybe that happens to be the cell where\nthe word, all, all portfolios is showing up right now. And we'll say select that cell. And then we're actually going to store\nthis cell address in our variable. So we'll say found, so dress equals\nactive, so address, so active cell dot address, whatever the act of sell\nin this case is going to be before. Of course, that's going to get\nstored in my variable and later on, because it's stored in my variable. I can actually compare it to whatever\nactive cell I'm in at that particular moment to determine whether or not\nI should continue the loop or not. Let's go ahead and move. Now I am going to need some code in here\nthat actually goes finding some things. So in order to do this, I'm going to\nopen up a completely blank document here. Let's put some words in\nhere, portfolio portfolio. So I'm going to put that a couple\nof times in there, and we should probably do that before we actually\ntry and record our fine macro. Otherwise it's not going to find anything\nand that's going to be recorded itself. So let's go ahead and type\nin those words portfolio. And now I can click on the macro recorder\nand here we go, find test and I'll click. Okay. And what I'm going to do is go to the\nhome tab and find my fine tool, and I'm going to choose find, and here we go. I'm looking for the word port folio\nand I click on find next and find next. I clicked on that twice, just so\nI can get a couple of iterations. I wanted to find it the first\ntime, and then I also want it to. Execute a little bit of code that is find\nnext, which you will see in just a second. So I did click that twice and now I'm\ngoing to click on close and I'm going to stop recording my macro and then\nI'm going to go look at the code. So here we go, going into the\nmodule that was just created by my macro recorder in this book one. And here is your find code. It has two different statements. Here. You have the statement for the very first\nfind, which has all the details about how this find is going to work, where it's\ngoing to start, whether it's going to look for casing, sensitivity, stuff like that. And then you'll have these statements\nat the end that say cells dot find next. If you want to do this multiple\ntimes, you would just say cells dot, find next cells dot find\nnext, over and over and over again. Now we were only going to need one. Cause we're going to create a loop to\ndo this over and over and over again. What I want you to do is\nactually copy all this content. And we're going to put it inside\nthe macro that we are designing. So I'm going back to my main file here,\nwhich is the file called find macros. And I'm going to go down into the\ncode that I am designing down here, and I'm going to paste paste that code\nthat my macro recorder just created. All right. So what my code is going to do so far is\nstore the given cell address that we've already selected in a particular variable. And then it's actually going to\nactivate its very first find. Now once it actually finds something,\nI'm going to want it to format it, right? That's the whole point of all of this. So I'm going to go ahead and\nput in some formatting stuff. I'm going to start my\nwith end with statement. That's going to allow me to only\ntype selection dot font once. And now I can just put in all the\nother statements like name equals. And let's say the size is going to be\n14 and maybe we'll make it bold too. That's my whole width statement. So I'm going to say end with all right. So this is going to format all\nof my content here, and I'm going to indent that a little bit. So it's more visually pleasing for me. Now, I'm going to want to be able\nto do this every single time. And as soon as it's done formatting,\nI'm going to want it to then after this go and find the next cell. So I'm going to want it to format\nthings and then find the next cell and then format things and then\nfind the next cell and then format things and then find the next cell. So what I'm going to do is actually\nput a do loop around the outside of this, which is going to allow\nthis to iterate multiple times. So here I go, put it in my do loop. And I'm going to use a loop while. And if you remember from earlier, we were\nsaying that we're going to put a clause in here that allows the loop to end. When we end up on the cell that we\nstarted on this other, we started on that cell address is stored in\nmy found cell address variable. And we'll say that we want to continue\nlooping this while it is not exactly the same cell as the cell that\nI'm in at that particular moment. So active cell dotted dress so long as\nthe cell that I started on is not the cell that I'm actually in right now. I want it to keep going, but once it\ngoes all the way to the end comes all the way back around to the beginning\nand lands on the cell that I started on. Then I wanted to stop. So that's what I'm doing here. And what this is going to do is\nfind every incarnation of that word portfolio that actually shows up and. Now let's continue along the\nsame vein that we've been doing for the last few exercises. We do have a gen rep macro, and we're\ngoing to need that gen rep macro to now also call to our macro called\nfour find format portfolio, headers. Okay. So after the next X statement, after\nmy gen rep macro, from our last example, after it calls upon all\nthose different macros and then is able to copy the stuff over there\nand paste it on this final sheet. After all that is pasted over here,\nthen I want to actually run this little macro that we just created this\nfind format, port, headers, macro. And so after the next deck statement,\nI'm going to type call, find format. So I'm calling upon find format, port\nheaders, and now I should be able to run my gen rep macro over here, and it\nshould take care of the whole deal for me. So I'm going to go to my\nmacros and I'm going to say, run gen rep and click on run. And there it goes. Now I have each one of my portfolios. I have this nice little\nheader right above it. If you want to, I would encourage\nyou to actually go in here and try and change a little bit of the code. So maybe it puts in some red text\nor something like that instead of the, this normal black text. But anyway, it worked right. So that's the end of our\nreport generator session. When you have completed this, come on\nback and we're going to move on to some very different stuff, including message\nboxes and receiving end user input. Hello and welcome back to\nVBA programming for Excel. At this point, we're going to need to\nstart to be able to communicate to our audience members or our end users rather. And we're also going to be able to\nretrieve information back from them. And there are a couple of different\noptions that we're going to explore over the next session, in order to be able\nto do this, we're going to be creating some message boxes, and we're also\ngoing to be creating some input boxes. Now let's just start with the basics. A message box is a box that pops up that\ngives our end user a particular message. This is a really basic message. The standard, the most simple\nmessage that you could create. The coding looks like message box or MSG\nbox, and then whatever the words are that you want to say to your end user, you can\nmake some much more complicated messages using the other message box options. If you code your message box like\nsuch where you say message box and then the message is in quotations. And then you follow that with a comma. You can create all different\nkinds of specific message boxes by using your different VB options. Some examples are the VBS, no box,\nthe VB message box help button VB. Okay. Cancel VB. Okay. Only VB information VBS, no\ncancel and VB retry cancel. After that, we're going to start\nlooking at some input boxes as well. And this is actually gonna allow\nour end users to be able to type in something we're going to retrieve\nthat data from these input boxes. And then we're actually going\nto be able to do something special based on their input. Let's get a couple examples of how\nthese two kinds of input boxes work. I'm just going to open up a completely\nblank spreadsheet here and open up visual basic, and I'm going to insert a module. And insert also a procedure in\nhere and I'm, we're going to call this testing one, two, three. This is going to allow me to be\nable to test out some of this code. Now, if it's really simple here, I\nshould be able to actually put this code inside of the immediate window. So let's go ahead and test out a\nreally simple message box option. So that's going to say a message\nbox and then maybe it'll say something like hello world. And once I execute that, now\nI get this little message box pops up that says, hello world. Now, the way that that box looks is\nreally not determined by Excel at all. It's determined by windows on my computer. So there I have the simple message box. Hello world. If I wanted to be able to specify\nexactly what kind of a box this is going to be, I could say, make this a VB. Yes, no canceled that. And then I get the message\nsaying, hello world. And I have options to click. Yes and no. And cancel now at this\npoint, if I clicked, yes, it wouldn't matter if I clicked. No, it wouldn't matter. And if I clicked cancel, it\nwouldn't matter either because there's nothing that's actually\nreceiving the end user input here in order to receive end user input. What we're going to have\nto do is create a variable. That's actually going\nto receive that input. Now what's interesting is each one\nof these buttons, that's in my dialog boxes in my little pop-up boxes here. Each one of these buttons is\nactually associated with a digit it's associated with an integer. And if you wanted to test out and\nsee exactly which integer each one of these buttons is associated\nwith, you could use your immediate window to ask that question. So I could say what's VBS associated\nwith then once I hit enter, it's a. Six. It used to be a long time ago that people\nhad to know exactly what the number was associated with each one of these options. And they had to have those memorized. But now we have this, these thing called\nConstance VBS is a constant VB know is a constant VB cancels, a constant et cetera. And these are numerical values that\nare little bit more easy to understand for we regular people who don't\nhave all of the integers memorized. So what we can do is test out a\nlittle bit of macro code here. I'm going to create a variable. That's actually going to receive the\nend user input from this message box. And then it's going to do\nsomething special depending on what their input is there. So maybe I'm going to play a\ncute little trick on my coworker. And I'm going to say, would you\nlike to download the sunshine virus? Now, of course, we wouldn't want to\ndo this in a real world situation. Nothing cool about scaring our\ncoworkers, making them think that there's actually a virus that\nprobably would not be good at all. So I'm going to put in a VBS,\nno option for my box here. And maybe I even want to\nput a title on my box. Maybe I'll say it's a full day. Okay. So there's my message box. Now again, like I was saying\nbefore this isn't actually going to receive any end user input. So I'm going to need to\nput in a variable here. That's actually going\nto receive this input. So input received. I'm going to put in my parentheses\naround the outside of my dialogue. There we go. And now we can say that input that\nwas received by my message box, whether it's a six or whether it\nis a let's find out what VB no is Vivino is seven. So we'll say if input received equals six,\nthen maybe give us a message box that says hopefully in the sunshine. Otherwise we want it to say don't work too hard then. And I'll end my end of statement\nwith an end, if, and let's test this. I'll go ahead and run this. And of course I get this message\nthat says, would you like to download the sunshine virus again? We don't want to do this in the real\nworld, but it's kind of a cute idea here. And I'll say why. Yes, I do. I would rather be playing in the\nsunshine than working hard on this ridiculous spreadsheet all day. And it says, okay, cool. You're all sold and I'll click, okay. Now if I run it again, but this\ntime I say, no, it says, okay, well don't work too hard then. So I used an if then statement\nto be able to do this. And I also received user input\nfrom that particular message box that allowed me to do one thing. If the answer was six and do something\nelse, if the answer was not six, now it just so turns out that I don't\nactually have to test for VB yes. To see whether it's six or\nsee whether no is seven. I can actually say if input\nreceived equals the B yes. So I can write it that way\nand that'll work for me. Yes. Okay. If you haven't done so already, why\ndon't you go ahead and give this a shot, make yourself a message box that\nreceives user input from the end user. Now we did create a variable here, and\nif you want to be extremely careful, which I highly encouraged, we all do. You could say input received\nis a integer variable. Okay. Because it is receiving that numerical\nvalue associated with our constant there. And so it's storing that numerical value. Why don't you go ahead and give\nthat a shot and come on back. Another way to receive end user\ninput is to actually allow them to be able to type whatever they\nwant in a particular dialog box. And then we can receive that input,\nthe kind of dialogue box that we're going to use to be able to\ndo this is called an input box. So I'm going to go ahead\nand put in my input box. And then, uh, for this first example,\nwe're just gonna see the input box. So we're not actually going to receive\nany end user input, but I am going to need a message for my input box. So maybe I'll ask my end users to\nthink about this question here and then be able to type whatever they want. And then after that, I'm going to\ncreate some kind of a standard response. That's supposed to be\napplicable in every situation. So I'm just going to type in\na question here and my end users can type in their answer and maybe based on whatever they type\nin there, we'll say something standard. And if we run this, we'll get\nthis message box that pops up. And regardless of whatever, I type in\nhere, we're not actually receiving their response, but this is what it looks like. And my end user can type\nin whatever they'd like. And then when they click, okay,\nthey get this standard response, but maybe we actually want to be\nable to receive the end user's input and then be able to perform a\ncertain action based on that input. If I want to do that, I'm going to need to\ndo the same thing we did with the message box, which is to create a variable that's\nsupposed to house the end user's input. In this case, my end user is going\nto type in whatever they want. So I'm going to have to figure out\nsome kind of a variable data type that's going to allow my end-users to\ntype in whatever I think that they're going to type in, in this case. Maybe we'll say, I think my end\nusers are going to type in texts. So I'm going to create a variable that\ncan house some text data, and I'm going to give it a little bit more of a commonly\nseen VBA variable, naming convention, S T R response STR STR stands for. And then the word response is what\nI actually want to name my variable. So you'll see this all the time. People naming their variables\nwith these three letters at the beginning, that's supposed to\ndeclare what type of a data type is eventually going to be housed in it. That way it's going to help\nyou remember when you have your list of a ton of variables. Exactly. Which ones how's what kind of data. So I'm saying a dim STR response as\nstring, and then we'll actually use it to receive the input from this input box. So here we go. This variable is going to receive\nthis input and then maybe we actually want it to perform a certain action. Now, my VBA is getting a little bit\nspecific with me here, cause it's saying you need to have a more official syntax. So I didn't need my little\nparentheses in there. And you could put a title\non this particular box. If you want to do that too, you just\nput a comma over here and then put in a title, just put in something. And let's say we'll actually\nhave them name a sheet here. All right. So my end user is going\nto see this question. What would you like to name this sheet? And then they're going to type\nin something it's going to be stored in my variable here. And then I'm going to use my\nvariable to actually name my sheets. So we already know how to do this. I'm just going to say the active\nsheet that I'm on and the name of that active sheet is going to be my STR\nresponse, whatever my end user typed in. All right. So I'm going to go ahead and run this. What would you like to name this sheet? This is so cool. Click. Okay. And there we go. Now my sheet name. If you haven't done so already, why\ndon't you take a moment to go ahead and test this out and make sure\nthat you can receive end user input. You will need to create a variable type\nand then use your input box, which feeds the response from that input box into your\nvariable, and then perform some kind of an action that actually uses that response. Go ahead and give that a shot and come\non back and we'll take a look at a whole lot more dynamic examples now. You may have noticed that in this last\nexample, there were a couple of things that we weren't really able to do. First of all, my code is starting\nto run over to the right-hand side. I'm running out of space over here. And so eventually I'm going to want\nto start to use what's called a code continuation character, which\nallows me to essentially stop coding at that place and then continue\nmy coding on the next line down. Now, normally I wouldn't be able\nto do that because VBA would say, Hey, that's a problem. Uh, if I remove my code continuation\ncharacter, you'll see that VBA is saying, okay, this doesn't look okay here. So I'm going to use, what's called\na code continuation character. We're going to take a look at that. And the other thing that I want to be able\nto do is go into my text box and actually make certain textual up on a certain line. So for instance, maybe I wanted\nto say, Hey there, and then on a separate line, I wanted to say. What would you like to name this sheet? If I hit my enter key now, obviously\nyou'll see, it's saying you can't do that because again, in this circumstance,\nI'm having a problem where I'm trying to enter down to the next line in this\ncase, just within my input box and VBA is not prepared to be able to do that. And so in this case, I'm going to have to\nuse, what's called a VB C R L F constant. And we'll talk about\nboth of these right now. Our first example is the\ncode continuation character. It is an underscore that underscore\ndoes need to be proceeded with a space. And so you can kind of think about it. Like it's always two characters. We always have a space\nand then a underscore. Now you're not going to be able\nto do this within a message. So you're going to need to close out the\nquotations in a message and then it would really be best just to keep all of your\ntexts together and close it out with one final quotation and then put your code\ncontinuation character at the very end. That's the easiest way to. And then if we want to actually get our\nmessage to go down to the next level, like you see in this example message\nbox here, if we want to continue the code on the next line, you notice\nthis word on is pretty small, so it should be able to fit up here, but\nwe've used it as V B C R L F constant. And we have put concatenate\non either side of that. And what that allows us to do is basically\nforce a hard return within a line of text. So let's go ahead and test this out. I'm going to take the script that we\nwere using for our input box there. And I'm just going to remove it. We're going to go ahead and put, in\nsome example, text here, let's say I'm going to put in a message box. And so I'm going to say here's my\nresponse, but it's going to be an integer. So I'm going to call it int response as. And so I'm going to be using this variable\nto receive the input from my end user. And that's going to come\nfrom a message box that says, we'll use our silly little\nsunshine virus example. Again, remember, this is not\na real virus and we don't want to do this in a real situation. Don't wanna scare anybody like\nto download the sunshine virus so that I can go play in sunshine. So I'm going to put my comma now. Normally I would actually put in the\nVBS no here and say, what kind of a message box I want this to be, but I'm\nstarting to run out of space and I am not going to be able to see it anymore. So I am putting in a space and then\nputting in my code continuation character, which is the underscore. And then I can hit my hard\nreturn and move down to the next line and keep going over here. So VB. Yes, no. And we'll put a title here. It's a beautiful day. And that's my whole input\nbox or rather message box. And that input is being\nreceived by my variable. And maybe I'll put in a little if\nstatement here that says if the response is yes, then we want it to say something. And if the response is no, then\nwe want it to say something else. Last time we used an L statement. I'm just going to use a\ncouple if then's here. So here we go. I'm going to say if, if I N T response equals yes. If that's yes, then, and I'm going\nto move down to the next line so we can keep it all together. Then we're going to throw up a\nmessage box that says wonderful, who play in the sunshine. However, if they say no, Don't work too hard. Okay. And of course, if we run this, I'm\ngoing to have a problem because I didn't put my end Def in there. So I'm going to go ahead and\nput in my end deck, here we go. So it's going to ask, would you\nlike to go play in the sunshine and I'll say yes, I would. And it will say, okay, great. Go play in the sunshine now. Let's do it one more time. No, I don't want to play in the sunshine. It says, okay. Don't work too hard though. And I'll click. Okay. All right. So we used our code continuation\ncharacter in this example, but what if I want to be able to create\na hard return that goes down? So we have this line that\nsays well done or wonderful. Go play in the sunshine. Let's say we want it to say wonderful\nand then move down to the next line and then say, go play in the sunshine. So I'm going to put in my quotation\nmarks to finish out the text, wonderful. Put in a concatenate, her character. And then I'm putting in my\nfancy VB, C R L F constant. That's going to insert a hard return\nhere, and I'm going to concatenate that with my second line of text. And here we go, let's check it out. And that's what a hard return looks like\nwhen you put it in your VBA code, take a moment and practice these two tools here. You're going to want to make sure\nto practice your VBC, RLF constant. And you're also going to want to practice\nyour code continuation character. You can use the example that we've\ndone here and then come on back and we'll use this in a more realistic\nsetting so far in this class. We've actually seen if then\nstatements quite a few times. But we haven't really had\na chance to focus on them. So that's what we're\ngoing to be doing here. We're going to be using the tools\nthat we have been learning over the last couple of sections. So we're going to be using input\nboxes and message boxes and variables, and we're going to be using them\nwith if then statements to allow particular things to happen. If a criteria is met now, in order\nto do this, I'm going to remove all the code that I have in here. And I am still in a\ncompletely blank document. And now I have a completely blank\nprocedure here, and we're going to go ahead and start from scratch. Now, the purpose of this particular\nexample is to see a scenario in which I end up coding a little too much using\nif then's, and you'll find that a lot of people end up doing this because they want\nto create a lot of different avenues that are possible given a particular response. But the thing is that if then's\nended up creating a whole lot of. Typing, I need end up needing\nto do a lot of typing. And so after this, we will use the select\ncase statement or a structure in order to be able to make that a little bit faster. But for this first example, we're going\nto go ahead and do this by hand, and it will be a good practice in using the, if\nthen statements we have seen if then else. And right now we're going to see\nif then else F so here we go. Let's go ahead and do this. We're going to ask a question that has\nseven possible responses, and this is something I like to do in my classes,\nsimply for the purpose of giving us a little bit of practice with this. So, uh, here we go. So I'm making my variable, that's\ngoing to be a STR response and then STR response that variable is going to\nhouse the response from an input box. And we'll say which one of snow\nwhites, seven dwarves is your. And I'll be official here\nwith my syntax because VBA is going to want me to do that. Okay. So that allows you to put\nin seven different answers. That's going to be a\nwhole lot of coding here. I'm going to go ahead and get you started. And then we're going to pause and you\ncan finish out the rest of that code and then come on back and we'll learn\nan even faster way to do it for now. And if then statement is going\nto look like if, and then we'll put it in our logical test. So if the response\nreceived from my end user is the word grumpy. Then maybe we want a message box to\npop up that says something specific. So I'm going to put in message\nbox, and you're going to find that your, if then statements start\nto get a little bit particular, they can get a little bit glitchy. And so there is a particular\nway that you want to do this. You are going to want to indent\nthe line that says message box. I know that I've previously said\nthat you shouldn't have to do that, but there were a couple of little\nglitchy things here in Excel's VBA. And this happens to be one of them. Your, if then statements, if you're\ngoing to create a lot, you're going to want to indent this, this next line,\nthe results of your, if so, here we go. So if the response is grumpy, then\nwe'll say, I knew you were cool, or else we'll ask another question. If the answer is happy, then a particular scenario in which it will\ngive a message appropriate to that answer. Alright. So this is the point at which\nI'm going to pause the video. You're going to want to continue\nwith another line that says, Alison. And create a scenario response for\nevery single possible scenario. So we have grumpy happy sneezy,\ndoc, wheezy, sleepy, and dopey. I believe it's hard to remember. That's why it's one of those riddles. So I'm going to type\nit over here in Excel. And then you can pause the video. I'm not sure Weezy is\nactually one of them. All right. Well, you can email me and let\nme know which one I'm forgetting. And now you can pause the video and go\nahead and finish out all of your else. If statements until you have created\nseven different, if then you are going to want to end that with an end Def and\nthen come on back and we'll keep going. All right. So we have all of these different\nscenarios that we are testing for. And indeed, if we play this and somebody\ngoes ahead and type something in. We will need to make sure that our end\nuser is being pretty case specific by the way, because I just typed in sleepy, but\nit was all lowercase and nothing happened. So I'm going to run this again\nand try it again, but be sensitive to casing and I'll click. Okay. And then it says the response\nthat I've actually designed for that particular answer. For my end user, you may have\nnoticed a few minutes ago that we used an else statement. So let's take a look at the difference\nbetween using Ellis and else F using an LLC if allows us to test for a\nspecific, additional response, whereas else is going to be used if we want\nto create a possible scenario in which somebody might type anything else. So maybe if somebody doesn't\ntype exactly one of the answers above, then I want it to say. Whatever I wanted to say. And that else clause is going to\nallow me to create a response or an action or a result given that\nanybody typed anything that I didn't design using my, if then statements. So why don't you go ahead and\ngive that a shot, try typing in an else and then test it out. We should be able to run this macro\ntype in something and then actually get a response from our L statement. Whereas in the last scenario, before we\nactually put in this L statement, then if somebody typed in something, besides what\nwe were testing for, it, nothing happened. Now. If somebody types in something that we\nweren't looking for than it actually has a result here, go ahead and give that. You may be feeling like in this last\nparticular scenario that this was a lot of typing and you would be absolutely correct\na little bit more typing than most coders want to actually have to go through. And so if we're going to have a lot\nof different potential results from a few tests, it's easier to start\nusing the select case structure. So I'm actually going to remove all\nof my events and we're going to go ahead and do this from scratch, but\nusing a slightly more efficient method. So I'm going to keep my variable and I'm\ngoing to keep my inbox, which is actually going to feed a response to the variable. But instead this time I'm going\nto say select case, and then I'm going to say STR response. Okay. So I am selecting the\ncase of STR response. I'm going to provide a lot of\ndifferent cases, potential cases. For STR response. So this is basically an F if the case\nis that STR is, and then I could say in case one it's this in case two,\nit's that in case three, it's that in case four, it's that et cetera. So here I go saying select case,\nand I'm putting in my variable name there, and then I'm going to\nsay in the case that it is grumpy and that's pretty much all there is to it. And all I have to do is\ntype in my other cases here. And maybe one more case. And then if you were curious,\nyes, there is a case else. This particular else clause\ndoesn't actually need the colon. Like the last one did, the\nlast one was kind of weird. This one is case Ellis. And then I'll just put for any other\ncase that somebody might type in here, I'll, we'll get a message box that says whenever you would like, and then we do\nneed to close out our bookend with a end select statement and here we go running it and I get the answer of cool. Then I'll run it again. And we'll say some jibberish and that's our select case statement. Why don't you go ahead and give it\na shot and come on back for the next two videos, we're going to be using a\nfile called input boxes for storage. So please go ahead and open up that file. It's called input boxes for sorting,\nand that's where we're going to be using for the next couple of examples. The next example is going to be the\nbig one, but in order to prepare for that, we're going to need to be able to\ndeclare multiple different variables. And if you have to declare 10\nvariables, you'll find that that is far too much typing. And so what we can start to do is\nstart to declare multiple different variables on the same line. So I'm going to go ahead and\ndeclare some variables here. I'm going to eventually going\nto be using these in text boxes. So I'm going to make one called message. That's actually going to be the\nmessage that my text box reads. And then I will put in a comma and I\ncan put in the rest of my variables that are all going to be the same data type. So I'm going to have one called message. I'm going to have the one called title bar\ntext for the title bar in that input box. I'm going to have the one called\ndefault text for some default texts. That's going to show up in the input. I'm going to have one called sort value. That's going to be the particular short\nvalue that somebody could choose by. And these are all going\nto be string variables. So I'm going to go ahead and\ndeclare them all on the same line. This is going to avoid me having\nto do a bunch of extra typing. So here we go. I'm going to create one called message. I'm going to create one called title bar. Maybe I'll call it title bar TXT. I'm going to create one call\ndefault TXT, one called sort Val. And these are all string variables. And with this particular strategy,\nyou can declare multiple different variables on the exact same line. And then I have one more variable\nthat we're going to need to create, which is going to actually be the\ninteger response from a, from an input box or from a message by. It's going to be an\ninput box in this case. But, but because it's going\nto be an integer, I'm going to say this particular answer. Yes or no. As the answer, this one is going\nto be an integer and that's going to need to be on its own line. Using this method. You can declare multiple different\nvariables on the exact same line. Why don't you take a couple of\nseconds to go ahead and type this out. You can even test it out if you would\nlike you can create an input box that uses all of these fields now by simply filling\nthese fields with a particular value. So I could say the message equals and this way I could test it out. So I've plugged in message there. And now I'm actually gonna\nput an input box here and maybe all use the\nmessage as the prompt. And I can go ahead and run this. And indeed it is using my input\nthat I plugged in there and it's putting it right there. Because I'm using my variable\nin both of those cases. Why don't you take a second to\nat least declare all of your variables and come on back. We're not actually gonna use this\nsecond line here, so I'm going to delete it by the time we get back. And when you get back, we're going to\ncontinue coding this particular macro. If you've been following along with\nthe videos, I just want to remind you that this little text that we\nput in at the end of the last little practice session is not actually texts. I'm going to be using in this macro. So go ahead and remove it. However we do need our\nvariable declaration here. If you are just tuning in for this\nvideo for the very first time note that we are in a file called input\nboxes for sorting, and we have needed to declare multiple different\nvariables in order to get started. Our end goal of this particular\nmacro is to use a sort macro code that's already been created. And you'll see in the macro that's\nright above the one that we're working on, that there's actually a sort\nmacro code that's in there at the very beginning of this entire course,\nwe did discuss using sort and filter macros and how easy they are to record. So you probably want to\nrecord that kind of a macro. And then once you have actually recorded\nthe sort code, at least then you can start putting in some custom scripting. In this case, we're going to be\nputting in some custom scripting that allows an end user to actually\ntype in what they want to sort by. And this is particularly\nadvantageous because a lot of folks don't know how to sort in Excel. And so it'd be really nice if\nthere was some little box that popped up that said, Hey, how do\nyou want to sort by this option? Or by that option, they could\nsimply type in which one they want or click on a button. And then the whole sheet gets\nsorted by exactly what they. So here we are designing a few\nvariables and we're going to be using these variables in a input box. And I'm just going to use them to\ntemporarily store some text here that is then going to be used by my input box. So this probably wouldn't be necessary in\na real world situation in unless you were doing this for multiple different inboxes\nand you wanted to be able to reuse your variable over and over and over again. But in this case, we're only\ngoing to be using it once. So not necessarily the most realistic\nworld, real world example, but it's worth practicing and understanding the concept. So I'm going to go ahead\nand plug in some text here. That's going to be stored in\nthis variable called message. I'm going to say, enter a number. We'll have our end users actually\ntype in a number to start by. And then in one of the previous\nvideos, we learned how to create a hard return inside of an input box. And the way that we did that is\nwith the VB C R L F constant. If you need a little bit of a\nreminder on this, there is a previous video called the code continuation\ncharacter and VBC RLF constant. So you can go ahead and\ntake a look at that. If you've been running through the\nvideos straight through, then you probably are still remember what that is. Now, the hard part is remembering that\nwe actually need this, this concatenate or to combine whatever text is before\nit and whatever text is after it. So I'm going to go ahead and put in\nthat concatenate or my ampersand. And I'm going to put in VB C R L F, and\nthen I'm going to put another ampersand after, and I am running out of space here. So I am also going to use my\nhandy code continuation character. Now that's the underscore. I do need a space before it,\nand that's going to allow me to continue my code on the next line. And I can feel somewhat self-assured\nthat there's not a bunch of other stuff over here, because hopefully\nif I've been true to my own habits in VBA, then I will have put that code\ncontinuation character in there every. All right. So I'm going to continue my text\nbox here and here are their options. Remember, we've used this hard\nreturn, the VBC RLF constant. So we are now moving on to the\nnext line and here's option one. If they type in one, then this\nwill sort by date and time. And then I'm going to put in another\nhard return there, VBC R L F ampersand, so that they'll get those, their\nsecond option right underneath it. And I am going to put my code continuation\ncharacter, not that I would need to in this particular circumstance, but\nit might be nice for me to look at later on when I'm trying to remember\nexactly what I did with this code. So their second option is\ngoing to be by customer service rep then by date and time. So remember, this is all the texts\nthat's being used by my message. Variable. Let's go ahead and plug in the\nvalues for my other variables here. So the other variables that we had\nto worry about was titled bar TXT. This is just whatever you want\nyour title bar to say, you could have it say something like\nsort Carson call center log. That's what our title going to say. And then in that input box, it is possible\nfor you to put default texts that says something like enter one or two, which\nis going to be helpful for my end-user. Why don't you go ahead and catch\nup with me, make sure that you have declared all of your variables here\nand that you have actually plugged in texts for each one of these. Now you are going to be using another\ncouple of variables here in a little bit. We just haven't started using them yet. They are the sort Val variable\nand the yes, no answer variable. Don't worry about those. Let's just start with the message. Title, bar, text and default text. And when you've done that, come\non back and we'll keep going, continuing with your macro here. You're going to want to\nactually create this input box. And that input box is going to receive\ninput from the end user, which is going to feed into a variable and the variable\nthat we have prepared in order to be able to do this is called sort Val. So I'm going to say, okay, the sort\nVal variable is the input received from the input box and the input box is\ngoing to use the message as the prompt. You'll see that the word prompt is\nhighlighted in my hint window here. So message is the prompt and then\nhave created a variable called title bar TXT for the title. And I've created one call default,\ntext TXT for the default text there. And I'll just go ahead and close that. So this is my input box. It's going to display my message. It's also going to display the\ntitle bar that I programmed here. And it's going to show the default texts\nthat we've programmed here as well. And the input from that input\nbox is going to be received and stored in the sort Val variable. Okay, let's go ahead and\nmake our case structure. So instead of doing my ifs, which are\na little bit glitchy and a little bit difficult and can be rather lengthy,\nI'm going to use the select case structure that we've already learned. And we're going to say, we're going\nto declare that there's going to be some possible different cases\nfor the value called sort Val. So select case, the case that I'm going\nto be considering is sort Val, and now I'm going to provide different potential\noptions for case I don't actually have to indent here, but I'm doing it\nto make it more easy for me to see. So we're going to say if the case is one. So if my end user actually types\nin the string value of one. Then we want to call the\nmacro called date then time. And it just so happens that there's\nalready a macro created and stored in this particular file called date, then time. And we'll provide a second case here. If my end-user actually types\ninto that means that they want to see the representative and then\ndate, and then time there's a macro that we've made for that. And it's called rep sort. If they type in anything else,\nthen we want them to get another message that says, Hey, you didn't\nreally type in the right thing. Do you want to try again? So I'm going to put in a case else, which\nwe learned a couple of videos ago, so case ELLs, and then in the case that they\ntype in something besides one and two, then we want to message box to pop up that\nsays, Hey, you didn't type one or two. Do you want to try again? And we're actually going to\nstore whatever they choose. Yes or no? Yes. I want to try again or no. Those are integer values, right? Cause that's going to be a VBS. No, because that's going to be a message\nbox because those are integer values. I'm going to need to\nstore it in a variable. Good thing is we've already created\na variable called Y N answer and that is an integer variable. So let's go ahead and use that one. Y N answer is going to receive\nthe input from my message box. That's going to say, Hey,\nyou didn't type one or two. You want to try again and we'll\ngive the options of yes or no. And then maybe we'll make a little\nsimple if statement here that says if the variable, Y an answer,\nif my end-user actually typed in, yes, then we want it to. Start this all over by calling the, this\nmacro that we're creating right now. It's just going to rerun this macro. So it's going to call the sort by macro. So it's going to start it over from\nthe beginning, and then I'm going to need to put in my end, if, cause\nwe do need that closing statement. I'm not going to put another clause\nfor if the VB answer is no, because I pretty much want it to be like, if\nthey choose no, then nothing happens. Right. And that's exactly what's\ngoing to happen in this case. As we learned much easier in one\nof the earlier videos where we saw if then statements with no else, if\nthere's no else and somebody actually clicks, no, then nothing happens. Okay. So I'm putting in my book in there\nthat says, and if, and then of course I do need to close out my bookend. That is my select statement. So I'm going to say and select and\nwith that, I should be all done. And here we go. Let's check it out. So we'll go ahead and play. And then we have the option to sort\nby date and time or by customer service rep and date and time. And I could enter in the value of one\nand that it actually sorts by that particular order, or I could sort by\ntwo and then it sorts by that order. Now it just so turns out that\nmy data over here actually isn't sorted in any other order. So you can test this out by resorting it\nby some other order and then test it out one more time, one, and there it goes. Now you can actually see it happening. Now, if somebody types something\nelse, you should get a message that says you didn't type one or two. You would you like to try again? And if you click, yes, it should\nrun this entire process over again. So I'm clicking. Yes. And there we go. It worked, go ahead and test\nthis out for yourself, make sure that your entire macro works. And if you're wondering whether it's\nworking or not, you can come back and take a look at my code right here. And when you're all done, come\non back and we'll keep it. Chelsea Dohemann: Welcome back as\nwe move further into VBA, we'll need VBA to be able to remember things. So we're going to be starting to use. What's called variables. Variables are small pockets\nof computer memory used to store and retrieve information. We can use them to store numbers or text\nor ranges of cells, charts, or pretty much anything you're going to want to\nopen up the file called simple variables. And once you open that up, make sure to\nalso get open the visual basic window, and you'll see that there are a number\nof macros already created in here. Now, if I wanted to be able to retrieve\ncertain information from another location or retrieve certain information\nthat I've stored in VBA and be able to use it here in my interface, I'm\ngoing to need to use a variable to do. And here's how they work. First of all, we need to list exactly\nwhat kind of a variable this is. Notice the beginning of this statement\nstarts with the letters D I M that stands for declared in memory. And this is how we tell VBA\nthat we're going to be using the next word as a variable. This is essentially a pocket or a bowl\nor a backpack or something like that. Something that's going to be able to\ntemporarily store a bit of information. And then we need to explain for VBA,\nwhat kind of content is going to go in there in this case, I'm saying\nintegers are going to go in there. That's all that's going to go in there. And that's going to make it\neasy for VBA to keep that data size and appropriate size. In this case, the integer\nsize is rather small. And so I like to specify for\nVBA that it's going to be small. In this case, I actually\nassigned a number of. So I've already told VBA that\nI'm going to create this pocket. It's called a number, and now\nI'm going to give it a value. So I'm saying this thing that\nI made called a number of this little pocket, that's going to\nhold the value of two for now. And then in this third, little bit here,\nI've actually assigned a task for this I've said, okay, I have a cell range,\na five, and the value of that range. I want to be specific, stored value. And if I run this macro here,\nyou'll see that over here, the value of that cell has now changed. Now, of course, the formatting here\nneeds to be changed back to something like general for me to actually see the\nnumber two, or if I change that to a date format, of course it looks a little silly,\nbut if I wanted it to be January 2nd, 1900, I would have exactly what I wanted. All right, we're going to keep going. The next few examples are\nmostly for practice for you. In the next example, we're\nactually storing date values. This is an example of a date variable. So we're saying this is going\nto be a variable called a date. And the data type is going\nto be a date data type. Then we actually assign a value. We say, okay, this thing that we\nmade called a date, we're going to grab the content from . Now\nIwan is located right up here, and that happens to have a date in it. And so this is appropriate. I've stored this as a date data type,\nand now it's going to store dates. What you don't want to do is store\nvariables as the wrong data type. Now, there are lots of different\ndata types for variables. You want to make sure to use\nthe right kind of data type when you are creating a variable. If you're going to be\nusing texts, use text. If you're going to be using numbers,\nuse numbers, and if you're going to be using true or false, make\nsure to use the Boolean data. This is a list of common data types\nthat you'll want to be aware of. Numerical data types include the decimal\ndata type, which is not the smallest data type you can have, but it does\nallow you to have decimal placeholders, which is nice for you're going to be\ndoing calculations with many decimals. The double data type is for relatively\nsimple numbers, something with not too many decimal placeholders. And then you have the intruder\ndata type, which doesn't allow any decimal placeholders whatsoever. You'll see, as they're allowed\nto be more and more simple, they take up less and less space into\nyou're only taking up two bytes. There are many different\nkinds of text data types. The first one I've listed\nhere is called variant. Now variant doesn't actually need to\nbe text variant can hold anything, which is why it's called variant. That's also why it's so big. So you'll want to make sure not to\nuse variant unless you really truly don't know what kind of data is going\nto need to be housed in their event. The most common text data\ntype is the string data type. The size of that variable does\ndepend on the amount of content that you're storing there. So keep that in mind. It can hold quite a bit of content, but\nit can also take up a bit of space if it holds a lot of content and then you have\nthe char or care data type that handles mostly smaller sets of information. We also have the bullying and bite\ndatatypes bullying only handles true or false, which makes it\nrelatively small, only two bites. And then we have the smallest of\nthem, all the byte data type, which only takes up one bite and can\nonly hold values from zero to 255. And then we have a group of\nmiscellaneous data types here. We have the date data type that\nwe just saw an example, a moment ago, we have object data types\nthat can hold things like charts. And then we have the range data\ntype, which you may have seen in an example earlier, which actually\nremembers ranges of cells in your work. Coming back in our document here. You'll see that if you scroll\ndown a little bit, there is a macro called string variable. This is an example where you can\npractice creating a string variable. I'm going to do it really quick,\nand then you can do it on your own. I'm going to start by declaring my\nvariable with the dim as statement what's referred to as the dim, as course,\nD I M stands for declared in memory. So I'm going to name this a product as\nstring, and that's going to let VBA know that the only kind of content that's\ngoing to be stored here is string content. Now I'm actually going to place\nsome data inside of my variable by saying my variable that have named\na product that should hold the information that's in cell G three. So I'm going to say range T3 value\nthat's in that range should be stored in my variable called a. And now I'm going to\nactually use that content. Now that it's remembered that content\nI'm later going to be able to use it. And let's say later on in cell\nB five, I'm going to go on to be using that content a product. And if I run this macro here that I've\ncreated, you'll see that it puts in the name of that particular product there. It just so happens that I need to\nmake this column a little bit bigger. There we go. And now I can see the entire name. All right. So the rest of the variables that\nare in this worksheet are for you to practice on here's a number variable. If you scroll down, you'll see an\nexample where you can get to your variable to increase in value. And then at the bottom, there\nis a macro that is designed to run all of the above variables. There is a little bit of lingo\nin here called a call station. We are going to be talking\nabout that later on. So if you don't feel\ncompletely comfortable with it yet, don't worry about it. We're going to cover it. Go ahead and pause the video. Come on. Back when you're done, there are a\ncouple of other things that we want to know about variables before we go and\nstart using them in our VBA language. And here's what they are. There is a naming convention\nfor variables, and there's certain ways to treat them. First of all, this dim as statement\nis not actually necessary. However, if you don't include the dim\nas statement, then the data type that gets assigned to that variable is the\nvariant data type, which as we learned earlier is pretty byte expensive. So we want to avoid that. And so that's why we tend to put the\ndim as statement at the beginning of all of our variable names. Now you can force people to put in the\nDMS statement at the beginning of all of their variables in the way that we do\nthat is with an option explicit statement at the very top of our macro code. So you can go all the way to the top\nof your macro code, above your sub statement and type in option explicit. And that's going to make sure that\npeople have to declare their variables. They can't just go making any\nvariable that they want whenever they want by saying like, this\nis a variable and just using it. Okay. So we want to make sure that we do have\ndim as statements, and we're going to use the option explicit at the top of our\ncode in order to make sure people do that. The other thing that we want to be\naware of is that there is a naming convention for our variables. They have to start with a letter. They can't have any spaces and they\nneed to have 255 characters or fewer. I'll give us an example. So here's an example of an\ninappropriately named variable. I have a space and the moment I\ntry and execute that variable, it says you can't do that. Okay. So no spaces inside of our variable names. Also it needs to start with a letter. If I accidentally put a number as\nthe beginning, watch what happens. So it doesn't accept that either. And the third thing we want to be mindful\nof when we're naming our variables is not to name them after a existing\nproperty method, active sheet here. Now watch what happens when I hit enter\nit actually lets me name it that, and then I can store information inside\nof this variable type, for instance. And then I can use that later on. I'll say, I want to assign,\nsell a one as the value of what I've put inside that variable. And if I run this right now, It actually\ninserts that numerical value there. So it worked as a storage space. However, later on, if I decide to\nuse this particular variable and I actually want to use the object\nthat it's named after, maybe I want to rename my sheet here at the end. I want to rename my sheet, this\nwork, and now I want to run my code. It says, oh, I can't do that. So we also don't want to name\nour variables after any existing objects, properties, or methods. And if we stick to those guidelines,\nwe're going to be safe with our variables. And this last example, we were able\nto get VBA to fetch information about a particular product and populate it\non our list on the left-hand side. However, if we wanted to do that for\nmany different products, it would start to become rather time consuming\nto do that within VBA and less, we started to incorporate what's called. And that would be able to populate\ninformation for multiple different products in order to do that, you're going\nto want to open up a file called for next. The for next loop is going to be\nthe file that we're working on next. There are a few different kinds of\nloops within VBA, but we're going to be focusing on two different kinds\nof the for-next loop and the do loop. We're starting with the, for next loop. Go ahead and open up this file called\nfor next loop on the left-hand side, and then the VBA window associated\nwith it on the right hand side. You'll see that there's already some\ncode in here that's populated for you and you can use it to follow along with me. I'm going to create mine from scratch. Now loops do require us\nto create a variable. For an X loops are the first kind of loop\nthat we're going to be talking about. And what they do is they loop through\na certain process of specific number of times, meaning you tell it how many times\nto go through this particular process. If I wanted to, I could say I want\nit to happen 10 times or happen a hundred times or something like that. I'm going to need to declare a variable\nhere because eventually I'm going to want my loop to happen across all of\nthese different rows in this green area, on the left-hand side of our document. So I'm going to create a variable\ncalled X and I'm going to make it a integer variable because eventually it's\ngoing to be representing row numbers. And my row numbers are only ever integers. It basic for next loop starts\nwith the force statement. And then you declare exactly what\nthe value of your variable should be. So. For X equaling one to 10, that means\nthat this loop is going to happen when X is equal to one it'll happen when X\nis equal to two, it'll happen when X is equal to three to four, to five, to six,\nand every single possibility in between. Now I've already declared that X\nis an integer, which means that it can only happen when it's\nequal to one or two or three. It cannot do 1.2, 1.3,\n1.4 or anything like that. So in this case, X is only going\nto equal 1, 2, 3, 4, 5, 6, 7, 8, or nine or 10, meaning this loop is\ngoing to happen 10 times altogether. Now, what I want to eventually loop is the\nprocess by which I'm going to insert the value of 100 into each one of these cells. And so I'm going to use\nthe code that says cell. And I'm going to start with\ncell one, comma one, that's sell a one as we know it. And then I'm going to say, I\nwant that to have a value of 100. Now, if I executed this right now, well,\nit would have a problem because I've started a for-loop without the end of it. But if I were just to execute this\none little statement that says this sells line right here, the value of\n100, all I would do is input that value into cell a one, but I want\nthis to repeat every single time. So when X equals one, I\nwant it to be in row one. When X equals two, I want it to\nbe in row two when X equals three, I want it to be in row three. And so instead of actually putting the\nnumber of the rows here, what I can do is simply say X, because then when X\nequals one, the row will be one as well. When X equals two, the\nrole will be two as well. And I have to end my four next\nloop with the next statement. This is my ending bookend that basically\nsays to go back to the beginning and start the next loop for the next value of X. And if I execute this, it happens too fast\nfor me to watch, but the value of 100 got inserted into each one of these cells. Go ahead and give that a try\non your own and come on back. And the last example, I was very\neasily able to populate this entire column of information and exact\nnumber of times exactly as I wanted. However, if I wanted to populate the\nnext column over, I'm going to have a little bit of difficulty because\nthe way that my macro code is set up is to automatically presume that I'm\nonly going to operate in column one here, where it says column one, watch\nwhat happens if I change this to add. If I think maybe I can get the next\ncolumn over to happen and the next column after that and the next column after that\nand all the way through the 10 columns. After that, when I hit play, watch, when\nX is equal to one, it populates a one. When X is equal to two, it only\npopulates B2 when X is equal to three only see three, et cetera. So that's not exactly what I\nwant to be able to do here. I want to be able to populate more\ncolumns of information right here. I don't want to have that value that I'm\nlooking for populated across those rows. If you want to be able to populate\nmultiple columns or multiple rows with the same for next loop, you're\ngoing to need to create what's called a double for next loop, which is\nbasically nesting one inside the other. It's not as complicated as it sounds. We're going to start by declaring\ntwo variables this time one for each of the four next loops\nthat we're going to be CRE. I'm going to start creating my variables\nwith a very specific name, like I N T C O L I N T for integer and C O L as the\nname of what it's eventually going to fill, which is the column in this case. And I'm going to say, this\nis an integer variable, and I'll create one more for rose. Now that I've declared my variables, I can\ngo ahead and make my four next statement. So I'll start with my four. And I'll say when int call is\nequal to one through three. Okay. So I want three columns of\ninformation populated here. Okay. When, when it's equal to one through\nthree, well then my cells, I'll just start with the basics here. I want the value to say\nsomething like, wow, this word. And then of course, I'll have to end this\nnext statement by saying next into call. However, if I were to try and add\nthat second access onto my for-next loop, I'm going to need to add\na secondary for next loop inside of the one that I already have. So I'm going to start by placing my\ncursor at the end of the previous four. And I'm going to make\nanother one for int RO. And I'll say, I want this to\nhappen for 10 rows altogether. So one to 10. Now the trick with nesting one for\nnext loop inside of another is that whichever one is on the inside has to be\non the inside in both cases during the for statement and the next statement. So I'm going to make sure\nthat my next statement for my row is on the inside as well. And I'll say next int. Now, of course, this is only going to\nwork for cell a one at this point, unless I specify for my cells object that when\nintro equals one or two or three or four or five or six or seven, et cetera,\nthat I want that to get populated. And when the column equals one or two\nor three, that that gets populated and here we go, let's test it out. That's pretty cool. Give it a shot yourself and come on. And now we're going to take the\nidea of a double for-next loop and turn it into a triple for next loop. So the double was able to populate\ninformation down a column and across a row and create a, basically\na table of information for us. But what if we wanted to do this over\nmultiple different sheets, you could basically add a third dimension to your,\nfor next loop and be able to do that. It's going to require the exact\nsame principles that we learned in the double for next loop. So I'm going to declare three different\nvariables this time, one for columns, one for rose, and one for sheets. Then I'm going to put in the\nbeginning of my four statements. So I'm going to start with my\nfour statement for the sheet. And I want this to happen on this\nsheet and the following two sheets. This one happens to be number three in the\norder of all the sheets in the workbook. So I'm going to say three to five,\nand then I'm going to start my for next loop for the columns. And I want that to happen over\nthree columns and then my rose, and then the actual code\nthat I want to execute. I am going to need to be specific\nenough to say exactly which worksheet I want this to execute\non, but lucky for me, my variable is going to determine that for me. And then I'll do the same code\nthat we had last time, which is the cells using the variables. And then I'll input a value there. Uh, And I'm going to have to\nfinish out my next statements. They are going to have to be in\nreverse order of the four statements, just like we saw last time. And assuming I've spelled all my variables\ncorrectly, I should be able to press play. And then of course it happens\non this sheet on the next sheet and on the sheet after that a for each loop is a for next loop,\nbut it operates on entire collections. So in this case, we have a collection of\nworksheets in this workbook altogether. They make up the collection\ncalled worksheet. And so if I have something that's\na collection like worksheets, then I can say, I want to do this\nparticular thing to every single thing in that particular collection,\nI'm going to go ahead and establish a variable justice we have before. Except I'm going to say that this\nis actually a worksheet here, and we will be talking about the\nworksheet object and the worksheet collection later on in this course. But if I wanted to use the, for\neach loop to do this, it would look like this for each X in the\ncollection called worksheets. And maybe in this case, I just want to\nget a nice little message box to pop up. And we're going to be covering message\nboxes later on in this course as well. But maybe I want it to tell\nme exactly what the name of that particular worksheet is. And I'll concatenate this with\nX, which is my variable and the name of that particular worksheet. And then I'll finish out\nthis with my next statement. So it's finding each one of\nthese worksheets and telling me exactly what the name is, because\nthat's what I've asked it to do. So it's going to operate this particular\nfor next statement for every single one of the items, every single one\nof the worksheets in this case, in the collection called worksheets. Go ahead and give that\na shot and come on back. And finally, the last of the four\nnext statements we're going to cover is the one that actually\nrequires an exit for statement. The exit four statement is used\nto exit the, for next loop prior to the actual ending statement. Okay. So if you have a clause in here that would\nrequire you to exit the loop early, that's what the exit four statement is used for. Now, in this example, we're actually\ngoing to be utilizing an if then statement, which is something we're going\nto be covering later on in the course. So just go ahead and bear with. While we check out the\nexample of this, I'm going to declare my variable as normal. Then you use X and that's going\nto be an integer of course. And I'll say for X equals one\nto 50 for gemein equal sign. There we go. All right. And I'm going to say that I want\nto select range, be something and the road that's going to be\ndetermined here is going to be based on whatever my variable is at the moment. So when it goes through this the first\ntime I want to be on V1 when it goes through it, the second time I want\nto be on B2, when it goes through a third time, I want to be on B3. So I am going to use my\nvariable to determine that. And then I'm going to select that cell\nand I'm going to input a particular value. If the word doesn't stay, stop off. If the word stop is not\nalready populated in that cell. So I'm going to put a little test in here. It's basically going to say, do this,\nkeep doing this forever, unless you actually run into a value that's\nalready in that cell that says stop. And this is what that\nstatement would look like. Keep in mind, we haven't talked\nabout the, if then statement yet. So don't worry about completely\nfeeling comfortable with this, unless that cell says stop. In which case, exit my four statement. And that's what the exit four looks like\nnow in the case that it doesn't say stop. I do want it to continue going. So I'm going to use an LSF statement. And again, we are going to\ncover this later, so don't worry about it too much right now. And if it doesn't say the word stop,\nthen I want it to populate the word info over and over and over again. So we're going to be saying, if it says\nstop, then exit the forest statement. Otherwise if it's empty, then putting\nthe word info and we'll cover this later, but I do have to put in an end Def and\nthen of course, like we are used to, I do need to put in my next statement\nto finish out my for-next next loop. And then when I go ahead and play this,\nthe word info gets populated over and over and over again, until it runs into a\ncell that already has the value of stop. Go ahead and give this a shot for\nyourself and come on back and then we'll move on to other kinds of. In the last video, we saw an example of a\nloop that was going to perform its action over and over and over again and less,\nsome kind of a logical test was performed. And if that test equivocated to true, then\nthe loop would stop itself prematurely. That was the exit four statement\nthat allowed us to do that. But let's say we wanted to be able to\ncreate a loop whose sole job wasn't to do that loop a certain number of\ntimes like the four loop, but maybe what it was supposed to do is simply\nperform its task ad infinitum until some particular criteria was met. That's what we call a dual loop. Now there are a few different kinds of do\nloops that we're going to be exploring. We're going to start with the do wild. This loop performs its action\nover and over and over again. While a particular criteria is met. Another way of phrasing. This is to say that it performs\nits loop over and over again, while a certain test equals true. The moment that test equals false is\nwhen the loop actually stops itself. So if you open the file called dual\nloop on the very first sheet there, which is called the do while loop open\nup your visual basic for applications interface, and you'll see on the\nright-hand side, that there are already some macros in here that are designed\nfor you to be able to follow along. I'm going to remove the code\nwithin my macro so that we can go ahead and do it together. In this first example, what we're\ngoing to be doing is asking visual basic to perform a particular\ntask, a certain number of times. We're going to be asking it\nto perform this particular task while X is less than 10. In this case, we're going to be\nestablishing a variable, just like we did with the, for next loop. So I'm going to say dim X as\ninteger, and this is a do while loop. So I'm going to say do while\nX is less than a value of 10. Now I'm going to be using cells again\nto refer to each cell reference. And I'm going to be saying while the row\nis a numerical value of one or two or three or anything less than 10, I want\nit to select that particular row and stay in column one and put a value in there. Uh, let's say, cool. Here's the neat thing about the do loop. Now what I'm going to say is the new X. Equals X plus one. And with that, the value of\nax is actually increasing. Now I do need to put a\nbeginning value of X. So I'm going to go ahead and\ndo that here at the beginning. I'm going to say X starts as a value of\none, and then it goes through this loop. The last thing that it does in the\nmiddle of this loop is to add one to its own value, thereby increasing\nits value by one each time. And now I'm going to close out\nthe loop by putting the word loop at the end and let's run it. And there we go, go ahead and do that\nfor yourself and come on back and we'll look at the Duwell not empty. And this next example, we're going to be\nmanufacturing our own Dyl, not empty loop. So I'm going to start just as I\ndid before by declaring a variable. And I'm going to start with the\nvalue of five, because I want my loop to actually start on row five. I'm going to start by\nusing the do while loop. And I'm going to say, do while\nthe cell, the value of that cell is not, that's what those two\noperators next to each other mean. There is not empty. And by putting those two quotation next to\neach other, we are basically saying empty. All right. And then on the next line, I'm\nactually going to say what I want to happen in the loop. So while there's stuff in here, I want\nto perform the loop until it's empty. This is a process by which\nyou can basically have the auto-fill handle operate. Like you can imagine an\nautofill handle operating. If you were to do this in Excel\nand you were to double click on the auto fill handle and it populates\nto the bottom of a dataset. Well, that's basically what we're\ngoing to be manufacturing here. So we're going to be watching the\ncolumn to the left and we're going to be performing the following bit\nof code while the columns adjacent to it are filled with contents. So I'll say cells X three, that\nmeans whatever iteration of the loop we're on and in column three. And the value of that should be whatever comes from the\ncolumn to the left of it. I'm going to say plus 30 days, and that\nway I'm going to be using the dates on the left-hand side and adding 30 days to\npopulate a column of information about the due dates for these particular items. And then of course, I'm going to\nend my dilute by saying, okay, the next X equals X plus one. I'm going to finish that\nout with the loop bookend. Now I have all my due dates, give\nit a shot yourself and come on back. And now it would be helpful for us to be\nable to learn how to do a dual loop that instead of performing the loop wireless\ncertain criteria equivocates to true. Maybe we want to have a do loop\nthat performs its action until a criteria equivocates itself to true. That's what a do until\nloop is going to do. So I'm going to start off by\ndetermining my variable again. So I'm going to call this one intro. This is going to be my integer, and I'll\nstart off with a value of one for that. And then here's how the do until\nworks do until, and then you put whatever criteria needs to equivocate\nto true for this loop to stop it. Now, there's this really neat\nlittle clause that you can put in here, which is called is empty. And basically what it does is it,\nit performs a logical test to see if a particular cell is empty. All you have to do is specify which\ncell and I'll just say, cells intro. Okay. So what I'm doing right now is\nI'm performing a logical test to see is this cell empty? If this cell is not empty, it's\ngoing to continue the loop. If that criteria does equivocate to\ntrue in this case, this cell is empty, then it will actually stop looping. So here we go. Let's finish this out. I'll say in the case that it is not empty. I want you to change\nthe value of this cell to info. And then I do need to. Like normal with a Deloupes loops. I do need to increase the\nvalue of the next loop around. So there I go, applying my\nstep value, then I'm going to finish this out with the loop. And here we go. That is the do until loop, which\nperforms its action until a particular test equivocates to true\nin this case until a cell is empty. And there's one more iteration\nof the du antilope, which we call the do loop until this sort of\ndepends on your personal preference. Whichever one makes more sense to you\nis the one that you should utilize. There's not a whole lot of\nsituations in which you would need to use one rather than the other. However, it is pretty cool to go over. So let's talk about it instead of saying do,\nuntil we're going to say. And then way down farther, we're\ngoing to say loop until, okay. So here's how it's going to look. I do need to declare my variable. Of course, then I need to determine\nexactly which value that should start on. And then I'm going to say what I\nwant it to do over and over again. I'll choose the same word for this\nexample, and then I'll have it step up its value from the next time around. And then here's my loop until, and now\nI put my logical test here at the end. So this is just another option for you. Give that one up. And the real test is to see\nwhich one you like better. Some people like this, one, some people\nlike the one that we did before you decide on whichever one you like better is the\none that you should carry along with you. Now that we know how to create loops,\nwe're probably going to want to start to be able to generate reports\nbased on content that's already in our workbook in order to do so. We're going to need to know a few\nbasic vocab terms in VBA, and then we'll be able to really easily\nbegin to code report generators. A few bits of vocab that we're\ngoing to need to cover in this section is worksheets, including\nthe following worksheet stock count. That might count the number of\nworksheets that's in my workbook. And I could ask the question of\nthe immediate window, how many worksheets are in my workbook. It turns out that there are five. So I just used the worksheets\nobject and the count method in order to be able to determine. I can also use the offset method,\nwhich allows me to navigate from a given cell into other cells. For instance, if I take the cell that\nI've already selected, and then I put in an offset method, I can then specify\nwhere I want to move from the given cell. You can see that I've started by\nentering in the word selection. That's going to take into account the\ncell that already selected an offset from there, which means that I'm going\nto travel in a certain direction. Now, the offset allows me to determine,\nfirst of all, how many rows I want to travel downward or upward. If I use a negative number and then\nsecondarily allows me to determine how many columns I'm going to\nmove over to the right or left. If I use a negative number there in\nthis case, if I use a one comma zero that is indicating that I want to move\none row down and zero columns left. And then I will select that. And if I execute that in the immediate\nwindow, see my cell moves down one. I had some content in that particular\ncell that I wanted to be able to copy and paste in another location. I could simply say selection dot copy. And then I could say selection dot offset. I'm going to move down. And then I can say active sheet dot paste. Now the copy and paste\nis a little bit tricky. The copy is easy, but the piece\nis a little bit difficult when it comes to pasting you can't\nactually paste in a range. If you wanted to paste in a range, you\nneed to use the paste special option. The paste method is only a method\nof the active sheet object. And so keep that in mind, you are going\nto want to mention active sheet dot paste. If you want to use paste, or if you\nwant to use range or something else of the sort you want to use paste special. Like, so that's what\npay special looks like. Of course it doesn't apply to\nactive sheet, but nonetheless, that's what it looks like. All right. Keeping into account. All of these terms, we can very easily\ncreate a report generator in this document here, this document called\nworksheets count, offset, and copy. We're going to be able to\nexemplify all of the above also, including a simple for next loop. This is going to be a precursor to the\nfollowing exercise, which is going to be a little bit more challenging and\ntake into account everything that we've learned so far in this particular class. All right. So in this particular doctor, The\nlast sheet is called P and L, which of course stands for profit and loss. And let's say for instance, I want\nto be able to copy the information from all my other sheets. I have sources of revenue, other\nincome expenses, and taxes, and I want to be able to place them all on\nmy profit and loss sheet at the very end, in order to do that, I'm going to\nneed to create a loop that determines exactly how many sheets I have in my\nworkbook, and then is able to iterate that loop to copy and paste content\nfrom each given sheet, the appropriate number of times, depending on how many\nsheets actually have in that workbook. So I'm going to start by\ndeclaring a couple of variables. So I'm going to use X. This is going to be used\nfor my, for next loop. I'm going to say dim X, as\ninteger as we were doing with our four next loops previous. I'm also eventually going to want\nto save these sheet names from each of these sheets so that I can put\na little, a nice little label on my profit and loss statement, right\nabove where I'm going to paste the content from that particular sheet. So I'm going to go ahead and\ncreate a variable whose sole job is to remember the sheet titles. And though she titles are\ngoing to be stored as text. So I'm calling that a string\nvariable, and I'm going to start my for next loop for X equals one two. Now I could say five or four, rather\nbecause I want this to iterate four times. I have five sheets in total, but\nI don't want this to iterate for my profit and loss statement. So I'm going to say for X equals one to\nfour, but let's say for instance, in the future, I might add other expenses or I\nmight add other sheets into this workbook. I want it to be able to be\nrather flexible in that case. And so I'm going to have VB figure out\nwhat the count is of my worksheets. And then, because I don't want this\nto happen on the very last sheet. I only want this to iterate\nthe total number of sheets, except for this last one. I'm going to say worksheets dot count\nminus one to account for this last one. I don't want it to happen\nfor the fifth sheet. This is my final sheet here. All right. And then each time it goes through\nthis loop, I want it to grab the given worksheet for X this time. It will grab sheet one and it will select. And then I want it to immediately\nstore the sheet title. That's that variable that I had created\njust to remember the sheet title of the active sheet and the way that I do\nthat is by saying active sheet.name. And that's going to store the name\nof that particular active sheet. We learned how to use\nthe name method earlier. And then finally, I'm going to\ngo to the last sheet in here, which is called worksheet. It's called P and L. And I'm going to select it once there. I'm going to start with range a one. That's going to be a safe place\nto start, but from there, I'm going to need to offset or remove\ndown a certain number of roads. And I know that the amount of content that\nI generally tend to keep on these sheets is about four rows or so of information. So I'm just going to say selection\ndot offset, to move down to account for the content that maybe\nI've already placed in there. So we'll say offset a\ncertain number of times. Now, if I just said offset five\nrows or something like that, went to go paste the content from the\nsecond sheet, it would paste it over the content from the first sheet. So I'm going to say, instead of\njust counting five rows, I want you to multiply X times five. So the first time this goes\nthrough, it will offset by five. And the second time it goes\nthrough, it will offset by 10 rows. And the third time it goes\nthrough, it will offset by 15 rows. Now it's not actually going\nto offset by the full five rows as I'm thinking of them. It's gonna essentially\noffset is I four roses. We see them and that'll make a little\nbit more sense once we actually look at it, I'm going to put a plus two in here. That's going to give me a little bit of\nextra space in order to put my next title in there and then be able to go after\nthat and paste the content after that. So I'm going to put a plus two in here,\nand this is simply a trial by error thing. You would notice this, if you were\nmaking this macro on your own, you would be testing it out and\nyou would see that you need to put another couple of rows in here. And that's how this kind\nof things comes about. Then I'll select that cell. And I'm going to put in the title\nof this particular group of values that I'm going to be placing in here. Okay. So the value I'm going to put\nin there is the sheet title. From that very first sheet in\nthis case, maybe for good measure, I'll make it bold, make it look nice. All right. So we've put the title in there. Now we're going to have to go back to\nworksheet one or X rather select it and actually copy the content that we need. So I'm going to start by\nselecting reign J one. It just so happens that I keep\nall my content starting in cell, a one on that particular worksheet. And I don't know how much content is going\nto be there, but I want to grab it all. So I'm going to say selection dot current\nregion, which we talked about earlier. Dot copy. And then finally, I'm going\nto go to the sheets call. P N L select it. So I've selected the sheet I\nwant to be on, but what I want to do is take the active cell. Now, remember the active cell is wherever. I just pasted the title there. Okay. And I want to offset one\nrow down, select that cell. And then I'm going to say\nactive sheet dot paste. I'm going to finish out my, for\nnext loop by putting next decks. And finally, it's going to look a\nlittle bit funky at the end because it's going to offset by a whole lot. The very first time, the very first time\nit's going to offset by five rows plus two, which is going to look like seven. It's going to look a little bit awkward. So I'm going to grab rows. I only know this because\nI've done this before. No, grab those rows right there. Just a few of them, and\nI'm going to delete them. That's going to look kind of. All right now, if I were building\nthis from scratch, I would probably be stepping into this as I'm building it. So I'm going to go to the\nstep into process so that we can watch all of this happen. So here we go, starting with the very\nfirst X, which goes to the first sheet, grabs the sheet, title, copies it\nessentially, or rather stores it in a variable, goes to our P and L sheet starts\nfrom cell, a one offsets by seven puts in my sheet title there makes it bold. Then goes back to sheet one, copies. All the content here, goes\nback to my profit and loss. Offsets goes down by one and then\npastes here and then goes to the next iteration of this particular process. And if I step into the rest of this\nand go straight through it, you'll see that at the very end, when\nI put my last category in there. Now I have that big chunk of\nextra space, those extra rows. I remember I was saying at the very end,\nI'm going to have that weird little space. And so I'm going to select rows three\nthrough six, and I'm going to delete them. And there we go. And they got deleted. Everything got moved up and there's\nmy profit and loss statement. Go ahead and give this a shot\non your own and come on back. And then we'll have a nice big\nexercise to get a chance to practice everything that we've learned so far. Not that I know how to\ncopy and paste data. I now run into the issue sometimes of\nhaving a situation in which my data dump puts data in unpredictable places. For instance, I have a problem here\nwhere my data dump deliver some of the contents starting in row five, some of\nthe contents starting in row two, and some of the contents starting in row three. Now, eventually I'm going to want to be\nable to consolidate this all on one last sheet, but I am going to need to learn a\nfew little bits of VBA vocab in order to create a macro, that's going to find the\ncontent wherever it is on a given day. I'm going to start with a sheet\ncalled conservative and I'm in the document called address call and end. I am working within the macro\nin the module called completed. I am working within the macro called\nall macros, but that's because I'm working on the instructor file. You have a file called you try and\nin the, you try module, there's an area for you to follow along. And there are little directions in\nthere in the form of comments as well. All right. So I'm going to create a macro\nwhose job it is to travel along any particular column a and start\nto find the content that's there. It's also going to remember exactly\nwhere it found that content, so that later on it can grab all that content\nand then be able to copy it and paste it or move it to another location. I'm going to start by creating a variable. That's going to be able to later on\ncontain the content that corresponds to wherever the data starts in my worksheet. So I'm going to call this data start and\nI'm going to make this a string variable. That's going to store that cell address. It's a string for now, which\nwill work for me for now. And I'm going to start\nby selecting sell a one, just so happens that conveniently\nenough, my data dump does always start in column a it's just the road\nthat I'm a little bit unsure on here. And what I'm going to do is I'm going\nto use, what's called the end product. The end property allows me to\ntravel in any particular direction. And it stops when it sees\na break in the pattern. So if there's nothing in a certain\nnumber of cells, it will travel all the way until it finds something. If it starts in a cell that actually has\nsomething and I use the end property, it will then travel in a particular\ndirection until it finds nothing. Okay. So it's following the\nparticular pattern here. And indeed, if I use the immediate\nwindow to say the given selection, I want to end or rather travel\nin a particular direction, that's what this little bit of vocab does. And I'm going to specify the direction. I'm going to say XL down the other\noptions that we have our XL up. And then we also have\ntwo right or two left. I'm going to use XL down here. And then I'm going to say select and\nwatch what happens when I execute that it travels down to the beginning of\nmy data and actually selects that. So that's what the end\nmethod allows me to do. And then I want to be able to actually\nrecord the address of the particular cell, where I ended up there. What's going to allow me to\ndo this is the address method. So I could say selection dot address. And let's say, I turn this into a\nquestion from my immediate window. Watch what happens. It actually tells me what address\nthe cell is that I'm in right now. It does return it as an\nabsolute cell address. That's sort of one of the\nproperties of the address. And once I've done that, now\nwe'll be able to actually store that address in the variable that\nI've created called data start. And then later on, I'll be able to copy\nand paste all the content that I want. There are a couple of macros\nalready in here that select all the content and the current region,\nwhich we've already gone over. And then it also puts in some nice\nlooking headers for me as well. So they're already a couple\nof macros that are in here. That I'm going to use later\non, but for now, I'm going to focus on, is creating the macro. That's going to find the\ncontent wherever it starts. So I'm going to start in\nrange a one and select it. And then I'm going to say, okay,\nfrom the given selection, I want to use the end method to travel\ndown and select whatever cell it finds, whatever cell it ends up on. I want to store this in my variable. So I'm going to say data start\nequals the active cell dot address. And then maybe later on, somewhere\ndown the line, I want to actually refer to that range and I'll call it data\nstart, and then maybe I'll select it. This doesn't need to happen right away. It could happen much\nfarther down the line. I have stored this in my\nvariable, so it'll hang on to that until I exit this matter. Now that I've actually found the\ncontent that I want, or I think I have let's test it out to make\nsure that it's going to work. I'm going to click play. And indeed, I end up on cell a five. I'm going to click over\nhere, see if it works again. And there, it goes ending up on a five. If I go to one of my other sheets, I\nshould be able to click on this same button and it should be able to start on\na, to, and this one starts on a three. So my macro is working correctly. Now, while I got to get it to do is now\nthat it's actually found the content. I want it to be able to run\nthese other macros here. So copy and paste in a four, and\nthen maybe insert the headers as well in order to be able to do that. I'm going to need to ask\nthe other macros to run. And what I've done is I've created\nthis parent macro up at the top, whose job it is to run all the\nother macros that I've designed. And the statement that I'm going to use\nto call to those macros is called the. So I'm going to say, I'm going to\ncall to the macro called find data. Your macro is called, find your data. Then I'm going to call to copy\npaste in a four years is called copy paste in your a for, and then the third macro I have here\nis insert headers or insert headers. And once again, yours is\ncalled in your headers. Now that I've created all of these\nmacros and referred to them in one parent macro, all I should have to do\nis run this parent macro and it should take care of the whole job for me. And there it goes. Now I've put this handy little\nbutton in here, so you should be able to click on the button and it\nshould be able to run those as well. This is what it should look like if\nit completely works appropriately. Go ahead and give that. And when you're done, come on back. This is a practice video to allow us to\nrehearse everything that we've learned over the last session, we're going to\nbe creating a report generator, which is going to allow us to basically take\nall of the macros that we've created already, including this cool sort macro. We saw an example at the very\nbeginning of class of a sort of macro. This is an excellent Stuart macro here,\nand we also have a macro that inserts, columns and rows we've recorded. One of those earlier. We also created a macro that\ninserted some text for us. There's a macro that does all that. And then we also have a macro\nthat's going to format text. We created a macro earlier\nthat did that as well. However, what we're going to be doing in\nthis last example in this macro called gen rep is creating a report generator,\nwhich is what Jen rep stands for. Now. We're going to need to create our for-next\nloop, to be able to find a bunch of content and then be able to organize it. We also want our macro to go through\neach one of the sheets that are in this document, find all the content,\nmove it down a little bit, put in some headers format, those headers nicely. Now I do have macros that already\nformat headers, and insert those headers and insert columns above. And it's going to be able to do that\non every single one of these sheets. So I am going to need to call to\nthese macros that have already placed in here, and then I'm going\nto need to loop those multiple times that happens on multiple sheets. And then ideally on the very last\nsheet, I would love to be able to print out the content from each of those\nindividual sheets and place it directly. Right. I'm going to start by declaring\na variable that I'm going to be using in my, for next statement. So I'm going to call\nit X stem X as integer. And I'm going to start my four next\nstatement by saying four X is going to equal one to the total number\nof worksheets worksheet, stock count, except for the last one. So I'm going to put my minus one there. All right. And each time it iterates, I\nwant it to select the given worksheet, starting with one. That's going to select that worksheet. And then on that worksheet, it's going to\nsort the content on there, which I have a macro for in school sort last call. I'm also going to have it insert columns\nand rows, which are having a macro call. And all row. I also wanted to insert my headers. I have a macro for that called\ninsert text or insert TXT. And I want to format the content. I have a macro called FMT\nTXC that will do that. What this is going to do is\npush all the content, all each one of those sheets downward. And so I'm going to have one last sell\nhere that says all portfolios up here. And then the rest of my content\nis going to start underneath it on each one of those other sheets. So in this case, what I'm going to\nwant it to do is actually copy all that content and place it over here. So I'm going to say on each one of\nthose other sheets, select range B six, and then use a current region and select. And then it's going to be copying that\nfor the purpose of coming all the way back to this worksheet and pasting it. So now I'm going to say, go to\nworksheets called all portfolios, select the sheet, called all portfolios,\nand then I'm going to use my end property to be able to figure out\nwhere the previous content is ending. Okay. So I'm going to pay some content\nonce and then I don't want the next pace to paste directly over it. So I'm going to use the end property,\nfigure out exactly where the content that I previously pasted, where\nthat ends, wherever that ends. So a lot of folks like to navigate\nreally far down on their worksheet, farther than they will ever go with\nany pasted content and then use X L. In their end property. And what that is going to do is find\nthe very bottom cell in your worksheet that actually has data populated\nin it, or rather the bottom cell in that particular column that you're\ntraveling up in that has content in it. And then maybe I'll use my\noffset to navigate just a couple cells down Mel paste there. And that way I'm not going to be pasting\nover any content that's already there. So I'm going to start by\nselecting something really far down, I'll say B 2000, and then I'm going to use my\nend method to travel up L up we'll select whatever cell that. Then maybe I'll offset. I'll just move down a couple of rows\nthat way I'm not pasting over anything. Just two rows down, just select that cell. And then I'm going to put\nin a little title there. Notice in this case, I'm not actually\nstoring that worksheet name in a variable like we did in the last example,\nin this case, I'm just saying, Hey, that worksheet called such and such. Yeah. Put its name right here. And we did this in an earlier\nexample, and then I want the word portfolio to follow that. All right. So now that I got the title in here,\nlet's offset a little bit more. So we can actually pay some\nstuff, offset a couple more rows, and then we'll paste. Now we are going to have\nto put our next X in here. This is going to iterate\nthis multiple times over. And then finally, the last thing\nI'm going to need to do is clean up my columns a little bit. Cause they're going to look a\nlittle bit squished together. You probably already know how to\nautomate your columns in regular Excel. Here's how to do it in VBA. You're going to just refer to the columns\nthat you want to choose in this case. All that content is going to be in B3, E and then it's as easy as saying\nselection, not columns, not auto. I love that method. It's super easy to use. And assuming I don't have any spelling,\nmistakes that I missed while we were going through this, I should be able\nto execute this and it should be able to run this for every single one\nof my sheets, and then populate the final result on this particular sheet. And when I press play and choose\nmy gen rep or report generator and run it, there it goes. So I have all of my portfolios\nlisted there and also on all the other sheets in my workbook. I also have my nice titles put in here\nand formatted looks so much better. And there we go. Go ahead and give that a shot\nyourself and come on back. I'll move on to even more interesting. Welcome back. So we've made this really nice\nlooking macro over here, and it's created a nice little report at the\nend of our document here, and it is pasted each one of our portfolios. Now, the only thing I would like\nto improve a little bit is that I have these headers that say\nconservative portfolios, balanced portfolios, aggressive portfolios. And I do want that to be a\nlittle bit more nicely formatted on this final document here. So the last little bit of macro\ncode that we're going to incorporate into this port generator that we've\nbeen working on is a little bit of code that is going to format these. Now, this is a good opportunity\nto play with a new kind of code, which is the find. So there is a scripting\nstatement that allows us to be able to find certain stuff. And then later on we can\ndo something to it, right? So you may have used the find\nand select or the find and replace tools within Excel. And that's exactly what\nwe're going to be using. We are going to use the macro recorder to\ndo this because like the sort and filter macros, it happens to record very well. So we're going to start off our little\nbit of script with some manual scripting, and then we're going to actually create\nsome find script with the macro recorder. And then we're going to finish\nit out with a little bit more scripting, and then we'll be done. We are done with the file\ncalled report generator. So you can go ahead and\nclose out of that file. And now what we need to open is the\nfile called find macros the file called fine macros contains all the exact same\ncode that we've already been working on. And we're just going to\nadd a little extra piece. That's going to allow us to\nfind anytime the word portfolio. Is populated and then\nformat it a particular way. Now I'm going to need to put a loop\nin here so that it can find that word portfolio for every single sheet\nwhere it happens or rather for every single portfolio that we actually\nend up pasting here at the end. So I'm going to need to loop it for\nas many times as that particular word shows up in my spreadsheet. So I am going to need to put a loop in\nhere and I'm going to need to eventually put in a logical test that is able to end\nmy loop when a particular criteria is met. So the criteria that we're\ngoing to incorporate here, we're going to make a do loop. And the criteria that we're going to\nput in here is we're going to say, do loop while the cell that I started on\nis not the cell that I have ended up. So, as you may know, if you've used\nthe find and select tool or the find and replace tool, what it does\nis it finds, it goes looking for something, and then it goes looking\nfor the next thing after that. And so what you can do is you can\nhave it look for every incarnation of a particular word and then get\nit to format a particular way. And that's what we're going\nto be doing, but we do want it to eventually end that loop. And so what we're going to\nsay is, okay, I'm going to start on this particular cell. I'm going to find this particular word. And once I actually get back to that\nfirst cell, again, go through the whole document cycle, back around, come back\nto the beginning and land on that cell. That's when the loop should stop. So what I'm going to do\nis create a variable. That's eventually going to\nbe able to house the cell address of my original find. So I'm going to say found cell address,\nand this is going to be a string so that it can house the cell addresses. And we'll say that we'll\nalways start and sell before. Maybe that happens to be the cell where\nthe word, all, all portfolios is showing up right now. And we'll say select that cell. And then we're actually going to store\nthis cell address in our variable. So we'll say found, so dress equals\nactive, so address, so active cell dot address, whatever the act of sell\nin this case is going to be before. Of course, that's going to get\nstored in my variable and later on, because it's stored in my variable. I can actually compare it to whatever\nactive cell I'm in at that particular moment to determine whether or not\nI should continue the loop or not. Let's go ahead and move. Now I am going to need some code in here\nthat actually goes finding some things. So in order to do this, I'm going to\nopen up a completely blank document here. Let's put some words in\nhere, portfolio portfolio. So I'm going to put that a couple\nof times in there, and we should probably do that before we actually\ntry and record our fine macro. Otherwise it's not going to find anything\nand that's going to be recorded itself. So let's go ahead and type\nin those words portfolio. And now I can click on the macro recorder\nand here we go, find test and I'll click. Okay. And what I'm going to do is go to the\nhome tab and find my fine tool, and I'm going to choose find, and here we go. I'm looking for the word port folio\nand I click on find next and find next. I clicked on that twice, just so\nI can get a couple of iterations. I wanted to find it the first\ntime, and then I also want it to. Execute a little bit of code that is find\nnext, which you will see in just a second. So I did click that twice and now I'm\ngoing to click on close and I'm going to stop recording my macro and then\nI'm going to go look at the code. So here we go, going into the\nmodule that was just created by my macro recorder in this book one. And here is your find code. It has two different statements. Here. You have the statement for the very first\nfind, which has all the details about how this find is going to work, where it's\ngoing to start, whether it's going to look for casing, sensitivity, stuff like that. And then you'll have these statements\nat the end that say cells dot find next. If you want to do this multiple\ntimes, you would just say cells dot, find next cells dot find\nnext, over and over and over again. Now we were only going to need one. Cause we're going to create a loop to\ndo this over and over and over again. What I want you to do is\nactually copy all this content. And we're going to put it inside\nthe macro that we are designing. So I'm going back to my main file here,\nwhich is the file called find macros. And I'm going to go down into the\ncode that I am designing down here, and I'm going to paste paste that code\nthat my macro recorder just created. All right. So what my code is going to do so far is\nstore the given cell address that we've already selected in a particular variable. And then it's actually going to\nactivate its very first find. Now once it actually finds something,\nI'm going to want it to format it, right? That's the whole point of all of this. So I'm going to go ahead and\nput in some formatting stuff. I'm going to start my\nwith end with statement. That's going to allow me to only\ntype selection dot font once. And now I can just put in all the\nother statements like name equals. And let's say the size is going to be\n14 and maybe we'll make it bold too. That's my whole width statement. So I'm going to say end with all right. So this is going to format all\nof my content here, and I'm going to indent that a little bit. So it's more visually pleasing for me. Now, I'm going to want to be able\nto do this every single time. And as soon as it's done formatting,\nI'm going to want it to then after this go and find the next cell. So I'm going to want it to format\nthings and then find the next cell and then format things and then\nfind the next cell and then format things and then find the next cell. So what I'm going to do is actually\nput a do loop around the outside of this, which is going to allow\nthis to iterate multiple times. So here I go, put it in my do loop. And I'm going to use a loop while. And if you remember from earlier, we were\nsaying that we're going to put a clause in here that allows the loop to end. When we end up on the cell that we\nstarted on this other, we started on that cell address is stored in\nmy found cell address variable. And we'll say that we want to continue\nlooping this while it is not exactly the same cell as the cell that\nI'm in at that particular moment. So active cell dotted dress so long as\nthe cell that I started on is not the cell that I'm actually in right now. I want it to keep going, but once it\ngoes all the way to the end comes all the way back around to the beginning\nand lands on the cell that I started on. Then I wanted to stop. So that's what I'm doing here. And what this is going to do is\nfind every incarnation of that word portfolio that actually shows up and. Now let's continue along the\nsame vein that we've been doing for the last few exercises. We do have a gen rep macro, and we're\ngoing to need that gen rep macro to now also call to our macro called\nfour find format portfolio, headers. Okay. So after the next X statement, after\nmy gen rep macro, from our last example, after it calls upon all\nthose different macros and then is able to copy the stuff over there\nand paste it on this final sheet. After all that is pasted over here,\nthen I want to actually run this little macro that we just created this\nfind format, port, headers, macro. And so after the next deck statement,\nI'm going to type call, find format. So I'm calling upon find format, port\nheaders, and now I should be able to run my gen rep macro over here, and it\nshould take care of the whole deal for me. So I'm going to go to my\nmacros and I'm going to say, run gen rep and click on run. And there it goes. Now I have each one of my portfolios. I have this nice little\nheader right above it. If you want to, I would encourage\nyou to actually go in here and try and change a little bit of the code. So maybe it puts in some red text\nor something like that instead of the, this normal black text. But anyway, it worked right. So that's the end of our\nreport generator session. When you have completed this, come on\nback and we're going to move on to some very different stuff, including message\nboxes and receiving end user input. Hello and welcome back to\nVBA programming for Excel. At this point, we're going to need to\nstart to be able to communicate to our audience members or our end users rather. And we're also going to be able to\nretrieve information back from them. And there are a couple of different\noptions that we're going to explore over the next session, in order to be able\nto do this, we're going to be creating some message boxes, and we're also\ngoing to be creating some input boxes. Now let's just start with the basics. A message box is a box that pops up that\ngives our end user a particular message. This is a really basic message. The standard, the most simple\nmessage that you could create. The coding looks like message box or MSG\nbox, and then whatever the words are that you want to say to your end user, you can\nmake some much more complicated messages using the other message box options. If you code your message box like\nsuch where you say message box and then the message is in quotations. And then you follow that with a comma. You can create all different\nkinds of specific message boxes by using your different VB options. Some examples are the VBS, no box,\nthe VB message box help button VB. Okay. Cancel VB. Okay. Only VB information VBS, no\ncancel and VB retry cancel. After that, we're going to start\nlooking at some input boxes as well. And this is actually gonna allow\nour end users to be able to type in something we're going to retrieve\nthat data from these input boxes. And then we're actually going\nto be able to do something special based on their input. Let's get a couple examples of how\nthese two kinds of input boxes work. I'm just going to open up a completely\nblank spreadsheet here and open up visual basic, and I'm going to insert a module. And insert also a procedure in\nhere and I'm, we're going to call this testing one, two, three. This is going to allow me to be\nable to test out some of this code. Now, if it's really simple here, I\nshould be able to actually put this code inside of the immediate window. So let's go ahead and test out a\nreally simple message box option. So that's going to say a message\nbox and then maybe it'll say something like hello world. And once I execute that, now\nI get this little message box pops up that says, hello world. Now, the way that that box looks is\nreally not determined by Excel at all. It's determined by windows on my computer. So there I have the simple message box. Hello world. If I wanted to be able to specify\nexactly what kind of a box this is going to be, I could say, make this a VB. Yes, no canceled that. And then I get the message\nsaying, hello world. And I have options to click. Yes and no. And cancel now at this\npoint, if I clicked, yes, it wouldn't matter if I clicked. No, it wouldn't matter. And if I clicked cancel, it\nwouldn't matter either because there's nothing that's actually\nreceiving the end user input here in order to receive end user input. What we're going to have\nto do is create a variable. That's actually going\nto receive that input. Now what's interesting is each one\nof these buttons, that's in my dialog boxes in my little pop-up boxes here. Each one of these buttons is\nactually associated with a digit it's associated with an integer. And if you wanted to test out and\nsee exactly which integer each one of these buttons is associated\nwith, you could use your immediate window to ask that question. So I could say what's VBS associated\nwith then once I hit enter, it's a. Six. It used to be a long time ago that people\nhad to know exactly what the number was associated with each one of these options. And they had to have those memorized. But now we have this, these thing called\nConstance VBS is a constant VB know is a constant VB cancels, a constant et cetera. And these are numerical values that\nare little bit more easy to understand for we regular people who don't\nhave all of the integers memorized. So what we can do is test out a\nlittle bit of macro code here. I'm going to create a variable. That's actually going to receive the\nend user input from this message box. And then it's going to do\nsomething special depending on what their input is there. So maybe I'm going to play a\ncute little trick on my coworker. And I'm going to say, would you\nlike to download the sunshine virus? Now, of course, we wouldn't want to\ndo this in a real world situation. Nothing cool about scaring our\ncoworkers, making them think that there's actually a virus that\nprobably would not be good at all. So I'm going to put in a VBS,\nno option for my box here. And maybe I even want to\nput a title on my box. Maybe I'll say it's a full day. Okay. So there's my message box. Now again, like I was saying\nbefore this isn't actually going to receive any end user input. So I'm going to need to\nput in a variable here. That's actually going\nto receive this input. So input received. I'm going to put in my parentheses\naround the outside of my dialogue. There we go. And now we can say that input that\nwas received by my message box, whether it's a six or whether it\nis a let's find out what VB no is Vivino is seven. So we'll say if input received equals six,\nthen maybe give us a message box that says hopefully in the sunshine. Otherwise we want it to say don't work too hard then. And I'll end my end of statement\nwith an end, if, and let's test this. I'll go ahead and run this. And of course I get this message\nthat says, would you like to download the sunshine virus again? We don't want to do this in the real\nworld, but it's kind of a cute idea here. And I'll say why. Yes, I do. I would rather be playing in the\nsunshine than working hard on this ridiculous spreadsheet all day. And it says, okay, cool. You're all sold and I'll click, okay. Now if I run it again, but this\ntime I say, no, it says, okay, well don't work too hard then. So I used an if then statement\nto be able to do this. And I also received user input\nfrom that particular message box that allowed me to do one thing. If the answer was six and do something\nelse, if the answer was not six, now it just so turns out that I don't\nactually have to test for VB yes. To see whether it's six or\nsee whether no is seven. I can actually say if input\nreceived equals the B yes. So I can write it that way\nand that'll work for me. Yes. Okay. If you haven't done so already, why\ndon't you go ahead and give this a shot, make yourself a message box that\nreceives user input from the end user. Now we did create a variable here, and\nif you want to be extremely careful, which I highly encouraged, we all do. You could say input received\nis a integer variable. Okay. Because it is receiving that numerical\nvalue associated with our constant there. And so it's storing that numerical value. Why don't you go ahead and give\nthat a shot and come on back. Another way to receive end user\ninput is to actually allow them to be able to type whatever they\nwant in a particular dialog box. And then we can receive that input,\nthe kind of dialogue box that we're going to use to be able to\ndo this is called an input box. So I'm going to go ahead\nand put in my input box. And then, uh, for this first example,\nwe're just gonna see the input box. So we're not actually going to receive\nany end user input, but I am going to need a message for my input box. So maybe I'll ask my end users to\nthink about this question here and then be able to type whatever they want. And then after that, I'm going to\ncreate some kind of a standard response. That's supposed to be\napplicable in every situation. So I'm just going to type in\na question here and my end users can type in their answer and maybe based on whatever they type\nin there, we'll say something standard. And if we run this, we'll get\nthis message box that pops up. And regardless of whatever, I type in\nhere, we're not actually receiving their response, but this is what it looks like. And my end user can type\nin whatever they'd like. And then when they click, okay,\nthey get this standard response, but maybe we actually want to be\nable to receive the end user's input and then be able to perform a\ncertain action based on that input. If I want to do that, I'm going to need to\ndo the same thing we did with the message box, which is to create a variable that's\nsupposed to house the end user's input. In this case, my end user is going\nto type in whatever they want. So I'm going to have to figure out\nsome kind of a variable data type that's going to allow my end-users to\ntype in whatever I think that they're going to type in, in this case. Maybe we'll say, I think my end\nusers are going to type in texts. So I'm going to create a variable that\ncan house some text data, and I'm going to give it a little bit more of a commonly\nseen VBA variable, naming convention, S T R response STR STR stands for. And then the word response is what\nI actually want to name my variable. So you'll see this all the time. People naming their variables\nwith these three letters at the beginning, that's supposed to\ndeclare what type of a data type is eventually going to be housed in it. That way it's going to help\nyou remember when you have your list of a ton of variables. Exactly. Which ones how's what kind of data. So I'm saying a dim STR response as\nstring, and then we'll actually use it to receive the input from this input box. So here we go. This variable is going to receive\nthis input and then maybe we actually want it to perform a certain action. Now, my VBA is getting a little bit\nspecific with me here, cause it's saying you need to have a more official syntax. So I didn't need my little\nparentheses in there. And you could put a title\non this particular box. If you want to do that too, you just\nput a comma over here and then put in a title, just put in something. And let's say we'll actually\nhave them name a sheet here. All right. So my end user is going\nto see this question. What would you like to name this sheet? And then they're going to type\nin something it's going to be stored in my variable here. And then I'm going to use my\nvariable to actually name my sheets. So we already know how to do this. I'm just going to say the active\nsheet that I'm on and the name of that active sheet is going to be my STR\nresponse, whatever my end user typed in. All right. So I'm going to go ahead and run this. What would you like to name this sheet? This is so cool. Click. Okay. And there we go. Now my sheet name. If you haven't done so already, why\ndon't you take a moment to go ahead and test this out and make sure\nthat you can receive end user input. You will need to create a variable type\nand then use your input box, which feeds the response from that input box into your\nvariable, and then perform some kind of an action that actually uses that response. Go ahead and give that a shot and come\non back and we'll take a look at a whole lot more dynamic examples now. You may have noticed that in this last\nexample, there were a couple of things that we weren't really able to do. First of all, my code is starting\nto run over to the right-hand side. I'm running out of space over here. And so eventually I'm going to want\nto start to use what's called a code continuation character, which\nallows me to essentially stop coding at that place and then continue\nmy coding on the next line down. Now, normally I wouldn't be able\nto do that because VBA would say, Hey, that's a problem. Uh, if I remove my code continuation\ncharacter, you'll see that VBA is saying, okay, this doesn't look okay here. So I'm going to use, what's called\na code continuation character. We're going to take a look at that. And the other thing that I want to be able\nto do is go into my text box and actually make certain textual up on a certain line. So for instance, maybe I wanted\nto say, Hey there, and then on a separate line, I wanted to say. What would you like to name this sheet? If I hit my enter key now, obviously\nyou'll see, it's saying you can't do that because again, in this circumstance,\nI'm having a problem where I'm trying to enter down to the next line in this\ncase, just within my input box and VBA is not prepared to be able to do that. And so in this case, I'm going to have to\nuse, what's called a VB C R L F constant. And we'll talk about\nboth of these right now. Our first example is the\ncode continuation character. It is an underscore that underscore\ndoes need to be proceeded with a space. And so you can kind of think about it. Like it's always two characters. We always have a space\nand then a underscore. Now you're not going to be able\nto do this within a message. So you're going to need to close out the\nquotations in a message and then it would really be best just to keep all of your\ntexts together and close it out with one final quotation and then put your code\ncontinuation character at the very end. That's the easiest way to. And then if we want to actually get our\nmessage to go down to the next level, like you see in this example message\nbox here, if we want to continue the code on the next line, you notice\nthis word on is pretty small, so it should be able to fit up here, but\nwe've used it as V B C R L F constant. And we have put concatenate\non either side of that. And what that allows us to do is basically\nforce a hard return within a line of text. So let's go ahead and test this out. I'm going to take the script that we\nwere using for our input box there. And I'm just going to remove it. We're going to go ahead and put, in\nsome example, text here, let's say I'm going to put in a message box. And so I'm going to say here's my\nresponse, but it's going to be an integer. So I'm going to call it int response as. And so I'm going to be using this variable\nto receive the input from my end user. And that's going to come\nfrom a message box that says, we'll use our silly little\nsunshine virus example. Again, remember, this is not\na real virus and we don't want to do this in a real situation. Don't wanna scare anybody like\nto download the sunshine virus so that I can go play in sunshine. So I'm going to put my comma now. Normally I would actually put in the\nVBS no here and say, what kind of a message box I want this to be, but I'm\nstarting to run out of space and I am not going to be able to see it anymore. So I am putting in a space and then\nputting in my code continuation character, which is the underscore. And then I can hit my hard\nreturn and move down to the next line and keep going over here. So VB. Yes, no. And we'll put a title here. It's a beautiful day. And that's my whole input\nbox or rather message box. And that input is being\nreceived by my variable. And maybe I'll put in a little if\nstatement here that says if the response is yes, then we want it to say something. And if the response is no, then\nwe want it to say something else. Last time we used an L statement. I'm just going to use a\ncouple if then's here. So here we go. I'm going to say if, if I N T response equals yes. If that's yes, then, and I'm going\nto move down to the next line so we can keep it all together. Then we're going to throw up a\nmessage box that says wonderful, who play in the sunshine. However, if they say no, Don't work too hard. Okay. And of course, if we run this, I'm\ngoing to have a problem because I didn't put my end Def in there. So I'm going to go ahead and\nput in my end deck, here we go. So it's going to ask, would you\nlike to go play in the sunshine and I'll say yes, I would. And it will say, okay, great. Go play in the sunshine now. Let's do it one more time. No, I don't want to play in the sunshine. It says, okay. Don't work too hard though. And I'll click. Okay. All right. So we used our code continuation\ncharacter in this example, but what if I want to be able to create\na hard return that goes down? So we have this line that\nsays well done or wonderful. Go play in the sunshine. Let's say we want it to say wonderful\nand then move down to the next line and then say, go play in the sunshine. So I'm going to put in my quotation\nmarks to finish out the text, wonderful. Put in a concatenate, her character. And then I'm putting in my\nfancy VB, C R L F constant. That's going to insert a hard return\nhere, and I'm going to concatenate that with my second line of text. And here we go, let's check it out. And that's what a hard return looks like\nwhen you put it in your VBA code, take a moment and practice these two tools here. You're going to want to make sure\nto practice your VBC, RLF constant. And you're also going to want to practice\nyour code continuation character. You can use the example that we've\ndone here and then come on back and we'll use this in a more realistic\nsetting so far in this class. We've actually seen if then\nstatements quite a few times. But we haven't really had\na chance to focus on them. So that's what we're\ngoing to be doing here. We're going to be using the tools\nthat we have been learning over the last couple of sections. So we're going to be using input\nboxes and message boxes and variables, and we're going to be using them\nwith if then statements to allow particular things to happen. If a criteria is met now, in order\nto do this, I'm going to remove all the code that I have in here. And I am still in a\ncompletely blank document. And now I have a completely blank\nprocedure here, and we're going to go ahead and start from scratch. Now, the purpose of this particular\nexample is to see a scenario in which I end up coding a little too much using\nif then's, and you'll find that a lot of people end up doing this because they want\nto create a lot of different avenues that are possible given a particular response. But the thing is that if then's\nended up creating a whole lot of. Typing, I need end up needing\nto do a lot of typing. And so after this, we will use the select\ncase statement or a structure in order to be able to make that a little bit faster. But for this first example, we're going\nto go ahead and do this by hand, and it will be a good practice in using the, if\nthen statements we have seen if then else. And right now we're going to see\nif then else F so here we go. Let's go ahead and do this. We're going to ask a question that has\nseven possible responses, and this is something I like to do in my classes,\nsimply for the purpose of giving us a little bit of practice with this. So, uh, here we go. So I'm making my variable, that's\ngoing to be a STR response and then STR response that variable is going to\nhouse the response from an input box. And we'll say which one of snow\nwhites, seven dwarves is your. And I'll be official here\nwith my syntax because VBA is going to want me to do that. Okay. So that allows you to put\nin seven different answers. That's going to be a\nwhole lot of coding here. I'm going to go ahead and get you started. And then we're going to pause and you\ncan finish out the rest of that code and then come on back and we'll learn\nan even faster way to do it for now. And if then statement is going\nto look like if, and then we'll put it in our logical test. So if the response\nreceived from my end user is the word grumpy. Then maybe we want a message box to\npop up that says something specific. So I'm going to put in message\nbox, and you're going to find that your, if then statements start\nto get a little bit particular, they can get a little bit glitchy. And so there is a particular\nway that you want to do this. You are going to want to indent\nthe line that says message box. I know that I've previously said\nthat you shouldn't have to do that, but there were a couple of little\nglitchy things here in Excel's VBA. And this happens to be one of them. Your, if then statements, if you're\ngoing to create a lot, you're going to want to indent this, this next line,\nthe results of your, if so, here we go. So if the response is grumpy, then\nwe'll say, I knew you were cool, or else we'll ask another question. If the answer is happy, then a particular scenario in which it will\ngive a message appropriate to that answer. Alright. So this is the point at which\nI'm going to pause the video. You're going to want to continue\nwith another line that says, Alison. And create a scenario response for\nevery single possible scenario. So we have grumpy happy sneezy,\ndoc, wheezy, sleepy, and dopey. I believe it's hard to remember. That's why it's one of those riddles. So I'm going to type\nit over here in Excel. And then you can pause the video. I'm not sure Weezy is\nactually one of them. All right. Well, you can email me and let\nme know which one I'm forgetting. And now you can pause the video and go\nahead and finish out all of your else. If statements until you have created\nseven different, if then you are going to want to end that with an end Def and\nthen come on back and we'll keep going. All right. So we have all of these different\nscenarios that we are testing for. And indeed, if we play this and somebody\ngoes ahead and type something in. We will need to make sure that our end\nuser is being pretty case specific by the way, because I just typed in sleepy, but\nit was all lowercase and nothing happened. So I'm going to run this again\nand try it again, but be sensitive to casing and I'll click. Okay. And then it says the response\nthat I've actually designed for that particular answer. For my end user, you may have\nnoticed a few minutes ago that we used an else statement. So let's take a look at the difference\nbetween using Ellis and else F using an LLC if allows us to test for a\nspecific, additional response, whereas else is going to be used if we want\nto create a possible scenario in which somebody might type anything else. So maybe if somebody doesn't\ntype exactly one of the answers above, then I want it to say. Whatever I wanted to say. And that else clause is going to\nallow me to create a response or an action or a result given that\nanybody typed anything that I didn't design using my, if then statements. So why don't you go ahead and\ngive that a shot, try typing in an else and then test it out. We should be able to run this macro\ntype in something and then actually get a response from our L statement. Whereas in the last scenario, before we\nactually put in this L statement, then if somebody typed in something, besides what\nwe were testing for, it, nothing happened. Now. If somebody types in something that we\nweren't looking for than it actually has a result here, go ahead and give that. You may be feeling like in this last\nparticular scenario that this was a lot of typing and you would be absolutely correct\na little bit more typing than most coders want to actually have to go through. And so if we're going to have a lot\nof different potential results from a few tests, it's easier to start\nusing the select case structure. So I'm actually going to remove all\nof my events and we're going to go ahead and do this from scratch, but\nusing a slightly more efficient method. So I'm going to keep my variable and I'm\ngoing to keep my inbox, which is actually going to feed a response to the variable. But instead this time I'm going\nto say select case, and then I'm going to say STR response. Okay. So I am selecting the\ncase of STR response. I'm going to provide a lot of\ndifferent cases, potential cases. For STR response. So this is basically an F if the case\nis that STR is, and then I could say in case one it's this in case two,\nit's that in case three, it's that in case four, it's that et cetera. So here I go saying select case,\nand I'm putting in my variable name there, and then I'm going to\nsay in the case that it is grumpy and that's pretty much all there is to it. And all I have to do is\ntype in my other cases here. And maybe one more case. And then if you were curious,\nyes, there is a case else. This particular else clause\ndoesn't actually need the colon. Like the last one did, the\nlast one was kind of weird. This one is case Ellis. And then I'll just put for any other\ncase that somebody might type in here, I'll, we'll get a message box that says whenever you would like, and then we do\nneed to close out our bookend with a end select statement and here we go running it and I get the answer of cool. Then I'll run it again. And we'll say some jibberish and that's our select case statement. Why don't you go ahead and give it\na shot and come on back for the next two videos, we're going to be using a\nfile called input boxes for storage. So please go ahead and open up that file. It's called input boxes for sorting,\nand that's where we're going to be using for the next couple of examples. The next example is going to be the\nbig one, but in order to prepare for that, we're going to need to be able to\ndeclare multiple different variables. And if you have to declare 10\nvariables, you'll find that that is far too much typing. And so what we can start to do is\nstart to declare multiple different variables on the same line. So I'm going to go ahead and\ndeclare some variables here. I'm going to eventually going\nto be using these in text boxes. So I'm going to make one called message. That's actually going to be the\nmessage that my text box reads. And then I will put in a comma and I\ncan put in the rest of my variables that are all going to be the same data type. So I'm going to have one called message. I'm going to have the one called title bar\ntext for the title bar in that input box. I'm going to have the one called\ndefault text for some default texts. That's going to show up in the input. I'm going to have one called sort value. That's going to be the particular short\nvalue that somebody could choose by. And these are all going\nto be string variables. So I'm going to go ahead and\ndeclare them all on the same line. This is going to avoid me having\nto do a bunch of extra typing. So here we go. I'm going to create one called message. I'm going to create one called title bar. Maybe I'll call it title bar TXT. I'm going to create one call\ndefault TXT, one called sort Val. And these are all string variables. And with this particular strategy,\nyou can declare multiple different variables on the exact same line. And then I have one more variable\nthat we're going to need to create, which is going to actually be the\ninteger response from a, from an input box or from a message by. It's going to be an\ninput box in this case. But, but because it's going\nto be an integer, I'm going to say this particular answer. Yes or no. As the answer, this one is going\nto be an integer and that's going to need to be on its own line. Using this method. You can declare multiple different\nvariables on the exact same line. Why don't you take a couple of\nseconds to go ahead and type this out. You can even test it out if you would\nlike you can create an input box that uses all of these fields now by simply filling\nthese fields with a particular value. So I could say the message equals and this way I could test it out. So I've plugged in message there. And now I'm actually gonna\nput an input box here and maybe all use the\nmessage as the prompt. And I can go ahead and run this. And indeed it is using my input\nthat I plugged in there and it's putting it right there. Because I'm using my variable\nin both of those cases. Why don't you take a second to\nat least declare all of your variables and come on back. We're not actually gonna use this\nsecond line here, so I'm going to delete it by the time we get back. And when you get back, we're going to\ncontinue coding this particular macro. If you've been following along with\nthe videos, I just want to remind you that this little text that we\nput in at the end of the last little practice session is not actually texts. I'm going to be using in this macro. So go ahead and remove it. However we do need our\nvariable declaration here. If you are just tuning in for this\nvideo for the very first time note that we are in a file called input\nboxes for sorting, and we have needed to declare multiple different\nvariables in order to get started. Our end goal of this particular\nmacro is to use a sort macro code that's already been created. And you'll see in the macro that's\nright above the one that we're working on, that there's actually a sort\nmacro code that's in there at the very beginning of this entire course,\nwe did discuss using sort and filter macros and how easy they are to record. So you probably want to\nrecord that kind of a macro. And then once you have actually recorded\nthe sort code, at least then you can start putting in some custom scripting. In this case, we're going to be\nputting in some custom scripting that allows an end user to actually\ntype in what they want to sort by. And this is particularly\nadvantageous because a lot of folks don't know how to sort in Excel. And so it'd be really nice if\nthere was some little box that popped up that said, Hey, how do\nyou want to sort by this option? Or by that option, they could\nsimply type in which one they want or click on a button. And then the whole sheet gets\nsorted by exactly what they. So here we are designing a few\nvariables and we're going to be using these variables in a input box. And I'm just going to use them to\ntemporarily store some text here that is then going to be used by my input box. So this probably wouldn't be necessary in\na real world situation in unless you were doing this for multiple different inboxes\nand you wanted to be able to reuse your variable over and over and over again. But in this case, we're only\ngoing to be using it once. So not necessarily the most realistic\nworld, real world example, but it's worth practicing and understanding the concept. So I'm going to go ahead\nand plug in some text here. That's going to be stored in\nthis variable called message. I'm going to say, enter a number. We'll have our end users actually\ntype in a number to start by. And then in one of the previous\nvideos, we learned how to create a hard return inside of an input box. And the way that we did that is\nwith the VB C R L F constant. If you need a little bit of a\nreminder on this, there is a previous video called the code continuation\ncharacter and VBC RLF constant. So you can go ahead and\ntake a look at that. If you've been running through the\nvideos straight through, then you probably are still remember what that is. Now, the hard part is remembering that\nwe actually need this, this concatenate or to combine whatever text is before\nit and whatever text is after it. So I'm going to go ahead and put in\nthat concatenate or my ampersand. And I'm going to put in VB C R L F, and\nthen I'm going to put another ampersand after, and I am running out of space here. So I am also going to use my\nhandy code continuation character. Now that's the underscore. I do need a space before it,\nand that's going to allow me to continue my code on the next line. And I can feel somewhat self-assured\nthat there's not a bunch of other stuff over here, because hopefully\nif I've been true to my own habits in VBA, then I will have put that code\ncontinuation character in there every. All right. So I'm going to continue my text\nbox here and here are their options. Remember, we've used this hard\nreturn, the VBC RLF constant. So we are now moving on to the\nnext line and here's option one. If they type in one, then this\nwill sort by date and time. And then I'm going to put in another\nhard return there, VBC R L F ampersand, so that they'll get those, their\nsecond option right underneath it. And I am going to put my code continuation\ncharacter, not that I would need to in this particular circumstance, but\nit might be nice for me to look at later on when I'm trying to remember\nexactly what I did with this code. So their second option is\ngoing to be by customer service rep then by date and time. So remember, this is all the texts\nthat's being used by my message. Variable. Let's go ahead and plug in the\nvalues for my other variables here. So the other variables that we had\nto worry about was titled bar TXT. This is just whatever you want\nyour title bar to say, you could have it say something like\nsort Carson call center log. That's what our title going to say. And then in that input box, it is possible\nfor you to put default texts that says something like enter one or two, which\nis going to be helpful for my end-user. Why don't you go ahead and catch\nup with me, make sure that you have declared all of your variables here\nand that you have actually plugged in texts for each one of these. Now you are going to be using another\ncouple of variables here in a little bit. We just haven't started using them yet. They are the sort Val variable\nand the yes, no answer variable. Don't worry about those. Let's just start with the message. Title, bar, text and default text. And when you've done that, come\non back and we'll keep going, continuing with your macro here. You're going to want to\nactually create this input box. And that input box is going to receive\ninput from the end user, which is going to feed into a variable and the variable\nthat we have prepared in order to be able to do this is called sort Val. So I'm going to say, okay, the sort\nVal variable is the input received from the input box and the input box is\ngoing to use the message as the prompt. You'll see that the word prompt is\nhighlighted in my hint window here. So message is the prompt and then\nhave created a variable called title bar TXT for the title. And I've created one call default,\ntext TXT for the default text there. And I'll just go ahead and close that. So this is my input box. It's going to display my message. It's also going to display the\ntitle bar that I programmed here. And it's going to show the default texts\nthat we've programmed here as well. And the input from that input\nbox is going to be received and stored in the sort Val variable. Okay, let's go ahead and\nmake our case structure. So instead of doing my ifs, which are\na little bit glitchy and a little bit difficult and can be rather lengthy,\nI'm going to use the select case structure that we've already learned. And we're going to say, we're going\nto declare that there's going to be some possible different cases\nfor the value called sort Val. So select case, the case that I'm going\nto be considering is sort Val, and now I'm going to provide different potential\noptions for case I don't actually have to indent here, but I'm doing it\nto make it more easy for me to see. So we're going to say if the case is one. So if my end user actually types\nin the string value of one. Then we want to call the\nmacro called date then time. And it just so happens that there's\nalready a macro created and stored in this particular file called date, then time. And we'll provide a second case here. If my end-user actually types\ninto that means that they want to see the representative and then\ndate, and then time there's a macro that we've made for that. And it's called rep sort. If they type in anything else,\nthen we want them to get another message that says, Hey, you didn't\nreally type in the right thing. Do you want to try again? So I'm going to put in a case else, which\nwe learned a couple of videos ago, so case ELLs, and then in the case that they\ntype in something besides one and two, then we want to message box to pop up that\nsays, Hey, you didn't type one or two. Do you want to try again? And we're actually going to\nstore whatever they choose. Yes or no? Yes. I want to try again or no. Those are integer values, right? Cause that's going to be a VBS. No, because that's going to be a message\nbox because those are integer values. I'm going to need to\nstore it in a variable. Good thing is we've already created\na variable called Y N answer and that is an integer variable. So let's go ahead and use that one. Y N answer is going to receive\nthe input from my message box. That's going to say, Hey,\nyou didn't type one or two. You want to try again and we'll\ngive the options of yes or no. And then maybe we'll make a little\nsimple if statement here that says if the variable, Y an answer,\nif my end-user actually typed in, yes, then we want it to. Start this all over by calling the, this\nmacro that we're creating right now. It's just going to rerun this macro. So it's going to call the sort by macro. So it's going to start it over from\nthe beginning, and then I'm going to need to put in my end, if, cause\nwe do need that closing statement. I'm not going to put another clause\nfor if the VB answer is no, because I pretty much want it to be like, if\nthey choose no, then nothing happens. Right. And that's exactly what's\ngoing to happen in this case. As we learned much easier in one\nof the earlier videos where we saw if then statements with no else, if\nthere's no else and somebody actually clicks, no, then nothing happens. Okay. So I'm putting in my book in there\nthat says, and if, and then of course I do need to close out my bookend. That is my select statement. So I'm going to say and select and\nwith that, I should be all done. And here we go. Let's check it out. So we'll go ahead and play. And then we have the option to sort\nby date and time or by customer service rep and date and time. And I could enter in the value of one\nand that it actually sorts by that particular order, or I could sort by\ntwo and then it sorts by that order. Now it just so turns out that\nmy data over here actually isn't sorted in any other order. So you can test this out by resorting it\nby some other order and then test it out one more time, one, and there it goes. Now you can actually see it happening. Now, if somebody types something\nelse, you should get a message that says you didn't type one or two. You would you like to try again? And if you click, yes, it should\nrun this entire process over again. So I'm clicking. Yes. And there we go. It worked, go ahead and test\nthis out for yourself, make sure that your entire macro works. And if you're wondering whether it's\nworking or not, you can come back and take a look at my code right here. And when you're all done, come\non back and we'll keep it."

### Ran Playwright code
await page.evaluate('() => {\n  const segments = document.querySelectorAll(\'yt-formatted-string.segment-text\');\n  const texts = [];\n  segments.forEach(seg => {\n    const text = seg.textContent.trim();\n    if (text) texts.push(text);\n  });\n  return texts.join(\' \');\n}');

### New console messages
- [WARNING] The resource https://rr3---sn-8pxuuxa-i5o6k.googlevideo.com/generate_204 was preloaded usi...
- [WARNING] The resource https://rr3---sn-8pxuuxa-i5o6k.googlevideo.com/generate_204?conn2 was preload...
- [WARNING] The resource https://i.ytimg.com/generate_204 was preloaded using link preload but not use...

### Page state
- Page URL: https://www.youtube.com/watch?v=MeKL_n6SiYY
- Page Title: (230) Excel VBA Advanced Tutorial - YouTube
- Page Snapshot:
```yaml
- <changed> generic "YouTube Video Player" [ref=e5]:
  - ref=e12 [unchanged]
  - generic:
    - generic:
      - generic:
        - generic: Mute
        - generic: M
  - generic [ref=e8903]:
    - generic [ref=e8905]: Now, if I wanted to be able to retrieve
    - generic [ref=e8907]: certain information from another
  - ref=e14 [unchanged]
```
